\relax 
\providecommand \babel@aux [2]{\global \let \babel@toc \@gobbletwo }
\@nameuse{bbl@beforestart}
\providecommand\hyper@newdestlabel[2]{}
\providecommand\HyField@AuxAddToFields[1]{}
\providecommand\HyField@AuxAddToCoFields[2]{}
\babel@aux{english}{}
\@writefile{toc}{\contentsline {section}{\numberline {1}Abstract}{2}{section.1}\protected@file@percent }
\@writefile{toc}{\contentsline {section}{\numberline {2}Introduction to NCCL}{2}{section.2}\protected@file@percent }
\@writefile{toc}{\contentsline {subsection}{\numberline {2.1}Comparison to MPI}{3}{subsection.2.1}\protected@file@percent }
\@writefile{toc}{\contentsline {subsection}{\numberline {2.2}Relevant NCCL internals}{3}{subsection.2.2}\protected@file@percent }
\@writefile{lof}{\contentsline {figure}{\numberline {1}{\ignorespaces Thread creation: User API $\to $ NCCL internal init $\to $ create ProxyService $\to $ create ProxyProgress.}}{4}{figure.1}\protected@file@percent }
\newlabel{fig:thread-creation}{{1}{4}{Thread creation: User API $\to $ NCCL internal init $\to $ create ProxyService $\to $ create ProxyProgress}{figure.1}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {2}{\ignorespaces Flow from User API to \texttt  {ncclProxyPost}}}{5}{figure.2}\protected@file@percent }
\newlabel{fig:proxy-post}{{2}{5}{Flow from User API to \texttt {ncclProxyPost}}{figure.2}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {3}{\ignorespaces /src/proxy.cc \texttt  {ncclProxyProgress} progressing loop: progress ops, then get posted ops (or wait). }}{5}{figure.3}\protected@file@percent }
\newlabel{fig:proxy-progress-loop}{{3}{5}{/src/proxy.cc \texttt {ncclProxyProgress} progressing loop: progress ops, then get posted ops (or wait)}{figure.3}{}}
\@writefile{toc}{\contentsline {section}{\numberline {3}Profiler Plugin}{6}{section.3}\protected@file@percent }
\@writefile{toc}{\contentsline {subsection}{\numberline {3.1}Profiler plugin loading mechanism}{6}{subsection.3.1}\protected@file@percent }
\@writefile{lof}{\contentsline {figure}{\numberline {4}{\ignorespaces User API $\to $ NCCL communicator init $\to $ load profiler plugin and call \texttt  {profiler->init}.}}{7}{figure.4}\protected@file@percent }
\newlabel{fig:profiler-init}{{4}{7}{User API $\to $ NCCL communicator init $\to $ load profiler plugin and call \texttt {profiler->init}}{figure.4}{}}
\@writefile{toc}{\contentsline {subsection}{\numberline {3.2}Profiler API}{8}{subsection.3.2}\protected@file@percent }
\@writefile{toc}{\contentsline {subsubsection}{\numberline {3.2.1}init}{8}{subsubsection.3.2.1}\protected@file@percent }
\@writefile{toc}{\contentsline {subsubsection}{\numberline {3.2.2}startEvent}{9}{subsubsection.3.2.2}\protected@file@percent }
\@writefile{toc}{\contentsline {subsubsection}{\numberline {3.2.3}stopEvent}{10}{subsubsection.3.2.3}\protected@file@percent }
\@writefile{lof}{\contentsline {figure}{\numberline {5}{\ignorespaces Flow from NCCL API calls to profiler events. In case of \texttt  {ncclGroupStart / ncclGroupEnd}. multiple events of everything (except GroupApi) are called. Internally, some Collectives (e.g. ncclAlltoAll) are implemented as multiple p2p ops, triggering many P2pApi and P2p events.}}{12}{figure.5}\protected@file@percent }
\newlabel{fig:profiler-events}{{5}{12}{Flow from NCCL API calls to profiler events. In case of \texttt {ncclGroupStart / ncclGroupEnd}. multiple events of everything (except GroupApi) are called. Internally, some Collectives (e.g. ncclAlltoAll) are implemented as multiple p2p ops, triggering many P2pApi and P2p events}{figure.5}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {6}{\ignorespaces \texttt  {ncclProxyProgress}: progressOps emits ProxyStep/KernelCh/NetPlugin events. getPostedOps emits ProxyOp events. Several events ProxyCtrl are also emitted}}{13}{figure.6}\protected@file@percent }
\newlabel{fig:proxy-event-emission}{{6}{13}{\texttt {ncclProxyProgress}: progressOps emits ProxyStep/KernelCh/NetPlugin events. getPostedOps emits ProxyOp events. Several events ProxyCtrl are also emitted}{figure.6}{}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {3.2.4}recordEventState}{14}{subsubsection.3.2.4}\protected@file@percent }
\@writefile{toc}{\contentsline {subsubsection}{\numberline {3.2.5}finalize}{14}{subsubsection.3.2.5}\protected@file@percent }
\@writefile{lof}{\contentsline {figure}{\numberline {7}{\ignorespaces User API $\to $ \texttt  {commReclaim} $\to $ \texttt  {finalize} $\to $ plugin unload.}}{15}{figure.7}\protected@file@percent }
\newlabel{fig:profiler-finalize}{{7}{15}{User API $\to $ \texttt {commReclaim} $\to $ \texttt {finalize} $\to $ plugin unload}{figure.7}{}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {3.2.6}name}{15}{subsubsection.3.2.6}\protected@file@percent }
\@writefile{toc}{\contentsline {section}{\numberline {4}Code examples and visualizations}{15}{section.4}\protected@file@percent }
\@writefile{toc}{\contentsline {subsection}{\numberline {4.1}One Device per Thread}{17}{subsection.4.1}\protected@file@percent }
\@writefile{lof}{\contentsline {figure}{\numberline {8}{\ignorespaces One device per thread: A visualization of the calls generated to the Profiler API, starting from communicator creation, followed by a collective operation and communicator destruction. \texttt  {ProxyStep} events have been omitted for visual clarity, see Fig.~\ref {fig:multi-gpu-single-thread-show-proxystep} for a depiction.}}{18}{figure.8}\protected@file@percent }
\newlabel{fig:multi-gpu-single-thread-allreduce}{{8}{18}{One device per thread: A visualization of the calls generated to the Profiler API, starting from communicator creation, followed by a collective operation and communicator destruction. \texttt {ProxyStep} events have been omitted for visual clarity, see Fig.~\ref {fig:multi-gpu-single-thread-show-proxystep} for a depiction}{figure.8}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {9}{\ignorespaces One device per thread: In Fig.~\ref {fig:multi-gpu-single-thread-allreduce} \texttt  {ProxyStep} events have been omitted for visual clarity. However, in multinode settings, many additional profiler API calls for proxyStep events happen, informing about the low level network steps in their event details via \texttt  {recordEventState} (indicated as red circles above each of the event bars). The blue dotted lines indicate the \texttt  {parentObj} of each proxyStep event, which are the above proxyOp events.}}{19}{figure.9}\protected@file@percent }
\newlabel{fig:multi-gpu-single-thread-show-proxystep}{{9}{19}{One device per thread: In Fig.~\ref {fig:multi-gpu-single-thread-allreduce} \texttt {ProxyStep} events have been omitted for visual clarity. However, in multinode settings, many additional profiler API calls for proxyStep events happen, informing about the low level network steps in their event details via \texttt {recordEventState} (indicated as red circles above each of the event bars). The blue dotted lines indicate the \texttt {parentObj} of each proxyStep event, which are the above proxyOp events}{figure.9}{}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {4.1.1}Multiple Devices per Thread (ncclGroup)}{19}{subsubsection.4.1.1}\protected@file@percent }
\newlabel{sec:multiple-devices-per-thread-ncclgroup}{{4.1.1}{19}{Multiple Devices per Thread (ncclGroup)}{subsubsection.4.1.1}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {10}{\ignorespaces Multiple devices per thread: Events from the proxy thread as well as init and finalize calls are omitted. Collective API calls from multiple GPUs managed by a single thread only trigger a single \texttt  {GroupApi} event.}}{21}{figure.10}\protected@file@percent }
\newlabel{fig:single-gpu-single-process-ncclgroup-finalize}{{10}{21}{Multiple devices per thread: Events from the proxy thread as well as init and finalize calls are omitted. Collective API calls from multiple GPUs managed by a single thread only trigger a single \texttt {GroupApi} event}{figure.10}{}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {4.1.2}Aggregated operations}{21}{subsubsection.4.1.2}\protected@file@percent }
\@writefile{lof}{\contentsline {figure}{\numberline {11}{\ignorespaces one GPU per thread with aggregated operations: multiple collective calls are grouped together and nccl does only a single kernel launch per thread.}}{22}{figure.11}\protected@file@percent }
\newlabel{fig:one-gpu-per-thread-grouped-collectives}{{11}{22}{one GPU per thread with aggregated operations: multiple collective calls are grouped together and nccl does only a single kernel launch per thread}{figure.11}{}}
\@writefile{toc}{\contentsline {section}{\numberline {5}Performance and scalability of the Profiler Plugin API}{22}{section.5}\protected@file@percent }
\@writefile{lot}{\contentsline {table}{\numberline {1}{\ignorespaces Profiler overhead: nccl-tests \texttt  {sendrecv\_perf} (P2P) and \texttt  {all\_reduce\_perf} (collectives). Latency averaged over 1M iterations.}}{24}{table.1}\protected@file@percent }
\newlabel{tab:profiler-overhead}{{1}{24}{Profiler overhead: nccl-tests \texttt {sendrecv\_perf} (P2P) and \texttt {all\_reduce\_perf} (collectives). Latency averaged over 1M iterations}{table.1}{}}
\@writefile{toc}{\contentsline {section}{\numberline {6}Discussion}{24}{section.6}\protected@file@percent }
\@writefile{toc}{\contentsline {subsection}{\numberline {6.1}Considerations for developers of a Profiler Plugin}{24}{subsection.6.1}\protected@file@percent }
\@writefile{toc}{\contentsline {paragraph}{Profiler Visualization.}{24}{section*.2}\protected@file@percent }
\@writefile{toc}{\contentsline {paragraph}{Correlating Collective Events with \texttt  {seqNumber}.}{24}{section*.3}\protected@file@percent }
\@writefile{toc}{\contentsline {paragraph}{Tracing low level activity back to NCCL API calls with \texttt  {parentObj}.}{24}{section*.4}\protected@file@percent }
\@writefile{lof}{\contentsline {figure}{\numberline {12}{\ignorespaces An example illustrating how \texttt  {parentObj} and \texttt  {seqNumber} can be used to better understand the timing of concurrent collective operations.}}{25}{figure.12}\protected@file@percent }
\newlabel{fig:phase-4-3rd-iter}{{12}{25}{An example illustrating how \texttt {parentObj} and \texttt {seqNumber} can be used to better understand the timing of concurrent collective operations}{figure.12}{}}
\@writefile{toc}{\contentsline {paragraph}{Process origin for profiler callbacks with PXN enabled.}{25}{section*.5}\protected@file@percent }
\@writefile{toc}{\contentsline {paragraph}{Tracking communicator parent--child relationships.}{25}{section*.6}\protected@file@percent }
\@writefile{toc}{\contentsline {subsection}{\numberline {6.2}Known limitations}{26}{subsection.6.2}\protected@file@percent }
\@writefile{toc}{\contentsline {subsection}{\numberline {6.3}Potential Integration with Score-P}{26}{subsection.6.3}\protected@file@percent }
\@writefile{lof}{\contentsline {figure}{\numberline {13}{\ignorespaces CUPTI activity is visualized as orange event bars. Through a correlation Id, it is possible to trace the activity back to \texttt  {KernelLaunch} events}}{27}{figure.13}\protected@file@percent }
\newlabel{fig:cupti-example}{{13}{27}{CUPTI activity is visualized as orange event bars. Through a correlation Id, it is possible to trace the activity back to \texttt {KernelLaunch} events}{figure.13}{}}
\@writefile{toc}{\contentsline {section}{\numberline {7}Conclusion}{27}{section.7}\protected@file@percent }
\gdef \@abspage@last{28}
