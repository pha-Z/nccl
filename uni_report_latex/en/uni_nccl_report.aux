\relax 
\providecommand \babel@aux [2]{\global \let \babel@toc \@gobbletwo }
\@nameuse{bbl@beforestart}
\providecommand\hyper@newdestlabel[2]{}
\providecommand\HyField@AuxAddToFields[1]{}
\providecommand\HyField@AuxAddToCoFields[2]{}
\babel@aux{english}{}
\@writefile{toc}{\contentsline {section}{\numberline {1}Abstract}{2}{section.1}\protected@file@percent }
\@writefile{toc}{\contentsline {section}{\numberline {2}About NCCL}{2}{section.2}\protected@file@percent }
\@writefile{toc}{\contentsline {subsection}{\numberline {2.1}Comparison to MPI}{2}{subsection.2.1}\protected@file@percent }
\@writefile{toc}{\contentsline {subsection}{\numberline {2.2}Relevant NCCL internals}{3}{subsection.2.2}\protected@file@percent }
\@writefile{lof}{\contentsline {figure}{\numberline {1}{\ignorespaces Thread creation: User API $\to $ NCCL internal init $\to $ create ProxyService $\to $ create ProxyProgress.}}{4}{figure.1}\protected@file@percent }
\newlabel{fig:thread-creation}{{1}{4}{Thread creation: User API $\to $ NCCL internal init $\to $ create ProxyService $\to $ create ProxyProgress}{figure.1}{}}
\@writefile{toc}{\contentsline {section}{\numberline {3}The Profiler API}{5}{section.3}\protected@file@percent }
\@writefile{toc}{\contentsline {subsection}{\numberline {3.1}How NCCL detects the profiler plugin}{5}{subsection.3.1}\protected@file@percent }
\@writefile{lof}{\contentsline {figure}{\numberline {2}{\ignorespaces Flow from User API to \texttt  {ncclProxyPost}}}{6}{figure.2}\protected@file@percent }
\newlabel{fig:proxy-post}{{2}{6}{Flow from User API to \texttt {ncclProxyPost}}{figure.2}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {3}{\ignorespaces \textbf  {/src/proxy.cc} \texttt  {ncclProxyProgress} progressing loop: progress ops, then get posted ops (or wait). }}{6}{figure.3}\protected@file@percent }
\newlabel{fig:proxy-progress-loop}{{3}{6}{\textbf {/src/proxy.cc} \texttt {ncclProxyProgress} progressing loop: progress ops, then get posted ops (or wait)}{figure.3}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {4}{\ignorespaces User API $\to $ NCCL init $\to $ load profiler plugin and call \texttt  {profiler->init}.}}{8}{figure.4}\protected@file@percent }
\newlabel{fig:profiler-init}{{4}{8}{User API $\to $ NCCL init $\to $ load profiler plugin and call \texttt {profiler->init}}{figure.4}{}}
\@writefile{toc}{\contentsline {subsection}{\numberline {3.2}The profiler API definition}{8}{subsection.3.2}\protected@file@percent }
\@writefile{toc}{\contentsline {subsubsection}{\numberline {3.2.1}init}{9}{subsubsection.3.2.1}\protected@file@percent }
\@writefile{toc}{\contentsline {subsubsection}{\numberline {3.2.2}startEvent}{10}{subsubsection.3.2.2}\protected@file@percent }
\@writefile{toc}{\contentsline {subsubsection}{\numberline {3.2.3}stopEvent}{11}{subsubsection.3.2.3}\protected@file@percent }
\@writefile{lof}{\contentsline {figure}{\numberline {5}{\ignorespaces Flow from NCCL API calls to profiler events. In case of \texttt  {ncclGroupStart / ncclGroupEnd}. multiple events of everything (except GroupApi) are called. internally, some Collectives (e.g. ncclAlltoAll) are implemented as many p2p ops, triggering many P2pApi and P2p events. Implementation: \textbf  {/src/init.cc}, \textbf  {/src/plugin/profiler.cc}.}}{12}{figure.5}\protected@file@percent }
\newlabel{fig:profiler-events}{{5}{12}{Flow from NCCL API calls to profiler events. In case of \texttt {ncclGroupStart / ncclGroupEnd}. multiple events of everything (except GroupApi) are called. internally, some Collectives (e.g. ncclAlltoAll) are implemented as many p2p ops, triggering many P2pApi and P2p events. Implementation: \textbf {/src/init.cc}, \textbf {/src/plugin/profiler.cc}}{figure.5}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {6}{\ignorespaces \texttt  {ncclProxyProgress}: progressOps emits ProxyStep/KernelCh/NetPlugin events. getPostedOps emits ProxyOp events. Several events ProxyCtrl are also emitted}}{13}{figure.6}\protected@file@percent }
\newlabel{fig:proxy-event-emission}{{6}{13}{\texttt {ncclProxyProgress}: progressOps emits ProxyStep/KernelCh/NetPlugin events. getPostedOps emits ProxyOp events. Several events ProxyCtrl are also emitted}{figure.6}{}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {3.2.4}recordEventState}{14}{subsubsection.3.2.4}\protected@file@percent }
\@writefile{toc}{\contentsline {subsubsection}{\numberline {3.2.5}finalize}{14}{subsubsection.3.2.5}\protected@file@percent }
\@writefile{lof}{\contentsline {figure}{\numberline {7}{\ignorespaces User API $\to $ \texttt  {commReclaim} $\to $ \texttt  {finalize} $\to $ plugin unload.}}{14}{figure.7}\protected@file@percent }
\newlabel{fig:profiler-finalize}{{7}{14}{User API $\to $ \texttt {commReclaim} $\to $ \texttt {finalize} $\to $ plugin unload}{figure.7}{}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {3.2.6}name}{15}{subsubsection.3.2.6}\protected@file@percent }
\@writefile{toc}{\contentsline {subsection}{\numberline {3.3}Code Examples}{15}{subsection.3.3}\protected@file@percent }
\@writefile{toc}{\contentsline {subsubsection}{\numberline {3.3.1}One Device per Thread}{16}{subsubsection.3.3.1}\protected@file@percent }
\@writefile{lof}{\contentsline {figure}{\numberline {8}{\ignorespaces One device per thread: First, the profiler API \texttt  {init} is called for each rank. This occurs during NCCL's internal communicator creation, roughly when the application calls \texttt  {ncclCommInitRank}. Then, the application calls \texttt  {ncclAllReduce}. This triggers many \texttt  {stateEvent}, \texttt  {stopEvent}, and \texttt  {recordEventState} calls to the profiler API. First, the \texttt  {groupApi} event starts (green bar). Below it, the startEvent and soon the stopEvent for the AllReduce \texttt  {collApi} event are called. The yellow bar shows when NCCL enqueues the GPU kernel launch (\texttt  {KernelLaunch} event). The two bars below represent the \texttt  {group} and \texttt  {coll} events. NCCL also spawns a proxy progress thread per rank, which makes additional profiler API calls. The first red \texttt  {ProxyCtrl} event shows the proxy progress thread was asleep. Next, a new \texttt  {ProxyCtrl} event shows time for the proxy thread to append proxy ops. Then, appended ops start progressing (\texttt  {ProxyOps} events), which in \texttt  {op->progress()} starts \texttt  {ProxyStep} and \texttt  {KernelCh} events that inform about low level network activity. Network activity evntually completes and the AllReduce collective finishes. The next \texttt  {ProxyCtrl} event shows the proxy thread sleeping again. Finally, profiler \texttt  {finalize} is called, which happens when the application cleans up NCCL communicators and no further communicators are tracked in the profiler in each respective thread. Matching \texttt  {coll} events across ranks can be identified for the same collective. This is shown by red lines connecting events with equal \texttt  {seqNum} values (from \texttt  {eDescr} in the profiler API \texttt  {init} call) across ranks }}{17}{figure.8}\protected@file@percent }
\newlabel{fig:multi-gpu-single-thread-allreduce}{{8}{17}{One device per thread: First, the profiler API \texttt {init} is called for each rank. This occurs during NCCL's internal communicator creation, roughly when the application calls \texttt {ncclCommInitRank}. Then, the application calls \texttt {ncclAllReduce}. This triggers many \texttt {stateEvent}, \texttt {stopEvent}, and \texttt {recordEventState} calls to the profiler API. First, the \texttt {groupApi} event starts (green bar). Below it, the startEvent and soon the stopEvent for the AllReduce \texttt {collApi} event are called. The yellow bar shows when NCCL enqueues the GPU kernel launch (\texttt {KernelLaunch} event). The two bars below represent the \texttt {group} and \texttt {coll} events. NCCL also spawns a proxy progress thread per rank, which makes additional profiler API calls. The first red \texttt {ProxyCtrl} event shows the proxy progress thread was asleep. Next, a new \texttt {ProxyCtrl} event shows time for the proxy thread to append proxy ops. Then, appended ops start progressing (\texttt {ProxyOps} events), which in \texttt {op->progress()} starts \texttt {ProxyStep} and \texttt {KernelCh} events that inform about low level network activity. Network activity evntually completes and the AllReduce collective finishes. The next \texttt {ProxyCtrl} event shows the proxy thread sleeping again. Finally, profiler \texttt {finalize} is called, which happens when the application cleans up NCCL communicators and no further communicators are tracked in the profiler in each respective thread. Matching \texttt {coll} events across ranks can be identified for the same collective. This is shown by red lines connecting events with equal \texttt {seqNum} values (from \texttt {eDescr} in the profiler API \texttt {init} call) across ranks}{figure.8}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {9}{\ignorespaces One device per thread: In Fig~\ref {fig:multi-gpu-single-thread-allreduce} \texttt  {ProxyStep} events have been omitted for visual clarity. However, in multinode settings, many additional profiler API calls for proxyStep events are done, informing about the low level network steps in their event details. The blue dotted lines indicate the \texttt  {parentObj} of each proxyStep event, which are the above proxyOp events.}}{18}{figure.9}\protected@file@percent }
\newlabel{fig:multi-gpu-single-thread-show-proxystep}{{9}{18}{One device per thread: In Fig~\ref {fig:multi-gpu-single-thread-allreduce} \texttt {ProxyStep} events have been omitted for visual clarity. However, in multinode settings, many additional profiler API calls for proxyStep events are done, informing about the low level network steps in their event details. The blue dotted lines indicate the \texttt {parentObj} of each proxyStep event, which are the above proxyOp events}{figure.9}{}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {3.3.2}Multiple Devices per Thread (ncclGroup)}{18}{subsubsection.3.3.2}\protected@file@percent }
\newlabel{sec:multiple-devices-per-thread-ncclgroup}{{3.3.2}{18}{Multiple Devices per Thread (ncclGroup)}{subsubsection.3.3.2}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {10}{\ignorespaces Multiple devices per thread: Events from the proxy thread are omitted. Grouped collectives within a thread only trigger a single \texttt  {GroupApi} event}}{20}{figure.10}\protected@file@percent }
\newlabel{fig:single-gpu-single-process-ncclgroup-finalize}{{10}{20}{Multiple devices per thread: Events from the proxy thread are omitted. Grouped collectives within a thread only trigger a single \texttt {GroupApi} event}{figure.10}{}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {3.3.3}One Device per Thread \& Grouped Collectives}{20}{subsubsection.3.3.3}\protected@file@percent }
\@writefile{lof}{\contentsline {figure}{\numberline {11}{\ignorespaces one GPU per thread with grouped collectives: multiple collective calls are grouped together and nccl does only a single kernel launch per thread.}}{21}{figure.11}\protected@file@percent }
\newlabel{fig:one-gpu-per-thread-grouped-collectives}{{11}{21}{one GPU per thread with grouped collectives: multiple collective calls are grouped together and nccl does only a single kernel launch per thread}{figure.11}{}}
\@writefile{toc}{\contentsline {subsection}{\numberline {3.4}Performance and scalability of the Profiler Plugin API}{21}{subsection.3.4}\protected@file@percent }
\@writefile{lot}{\contentsline {table}{\numberline {1}{\ignorespaces Profiler overhead: nccl-tests \texttt  {sendrecv\_perf} (P2P) and \texttt  {all\_reduce\_perf} (collectives). Latency averaged over 1M iterations.}}{22}{table.1}\protected@file@percent }
\newlabel{tab:profiler-overhead}{{1}{22}{Profiler overhead: nccl-tests \texttt {sendrecv\_perf} (P2P) and \texttt {all\_reduce\_perf} (collectives). Latency averaged over 1M iterations}{table.1}{}}
\@writefile{toc}{\contentsline {section}{\numberline {4}Discussion}{23}{section.4}\protected@file@percent }
\@writefile{toc}{\contentsline {subsection}{\numberline {4.1}Considerations for developers of a Profiler Plugin}{23}{subsection.4.1}\protected@file@percent }
\@writefile{toc}{\contentsline {paragraph}{Logging.}{23}{section*.2}\protected@file@percent }
\@writefile{toc}{\contentsline {paragraph}{Profiler Visualization.}{23}{section*.3}\protected@file@percent }
\@writefile{toc}{\contentsline {paragraph}{Tracking \& running metrics.}{23}{section*.4}\protected@file@percent }
\@writefile{toc}{\contentsline {paragraph}{Kernel tracing with CUPTI.}{23}{section*.5}\protected@file@percent }
\@writefile{lof}{\contentsline {figure}{\numberline {12}{\ignorespaces Illustration of CUPTI activity correlation with \texttt  {KernelLaunch} events. Kernel activity is visualized as orange event bars.}}{24}{figure.12}\protected@file@percent }
\newlabel{fig:cupti-example}{{12}{24}{Illustration of CUPTI activity correlation with \texttt {KernelLaunch} events. Kernel activity is visualized as orange event bars}{figure.12}{}}
\@writefile{toc}{\contentsline {paragraph}{Correlating Collective Events with \texttt  {seqNumber}.}{24}{section*.6}\protected@file@percent }
\@writefile{toc}{\contentsline {paragraph}{Tracing low level activity back to NCCL API calls with \texttt  {parentObj}.}{24}{section*.7}\protected@file@percent }
\@writefile{lof}{\contentsline {figure}{\numberline {13}{\ignorespaces An example illustrating how \texttt  {parentObj} and \texttt  {seqNumber} can aid in understanding nccl collective operations.}}{25}{figure.13}\protected@file@percent }
\newlabel{fig:phase-4-3rd-iter}{{13}{25}{An example illustrating how \texttt {parentObj} and \texttt {seqNumber} can aid in understanding nccl collective operations}{figure.13}{}}
\@writefile{toc}{\contentsline {paragraph}{Process origin for profiler callbacks with PXN enabled.}{25}{section*.8}\protected@file@percent }
\@writefile{toc}{\contentsline {paragraph}{Tracking communicator parent--child relationships.}{25}{section*.9}\protected@file@percent }
\@writefile{toc}{\contentsline {subsection}{\numberline {4.2}Known limitations}{26}{subsection.4.2}\protected@file@percent }
\@writefile{toc}{\contentsline {subsection}{\numberline {4.3}Potential Integration with Score-P}{26}{subsection.4.3}\protected@file@percent }
\@writefile{toc}{\contentsline {section}{\numberline {5}Conclusion}{26}{section.5}\protected@file@percent }
\gdef \@abspage@last{27}
