<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NCCL Profiler Timeline Visualization</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #f5f5f5;
            color: #333333;
            padding: 20px;
        }
        
        .container {
            max-width: 100%;
            margin: 0 auto;
        }
        
        h1 {
            color: #0d9488;
            margin-bottom: 20px;
        }
        
        .controls {
            background: #e8e8e8;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, auto));
            gap: 15px 20px;
            align-items: start;
        }
        
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        .control-group > label:first-child {
            font-size: 12px;
            color: #666666;
            height: 16px;
            line-height: 16px;
        }
        
        .control-group.event-type-group {
            grid-column: span 4;
        }
        
        .control-group.time-range-group {
            min-width: 180px;
            max-width: 250px;
        }
        
        .control-group.time-range-group > div {
            display: flex;
            gap: 5px;
            width: 100%;
        }
        
        .control-group.time-range-group input[type="number"] {
            flex: 1;
            min-width: 0;
            width: auto;
            box-sizing: border-box;
        }
        
        .control-group.checkbox-option {
            display: flex;
            flex-direction: row;
            align-items: center;
            gap: 5px;
            padding-top: 21px;
        }
        
        .control-group.checkbox-option label {
            font-size: 12px;
            color: #333333;
            cursor: pointer;
        }
        
        .type-filter-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
            padding: 3px 8px;
            background: #e0e0e0;
            border-radius: 3px;
            border: 1px solid #999;
            cursor: pointer;
            user-select: none;
            font-size: 11px;
            color: #333333;
            min-width: 40px;
            height: 24px;
        }
        
        .type-filter-btn:hover {
            background: #d5d5d5;
            border-color: #999;
        }
        
        .type-checkbox-item {
            display: flex;
            align-items: center;
            gap: 5px;
            padding: 3px 8px;
            background: #e0e0e0;
            border-radius: 3px;
            border: 1px solid #999;
            cursor: pointer;
            user-select: none;
            font-size: 11px;
            height: 24px;
        }
        
        .type-checkbox-item:hover {
            background: #d5d5d5;
            border-color: #999;
        }
        
        .type-checkbox-item input[type="checkbox"] {
            margin: 0;
            cursor: pointer;
        }
        
        .type-checkbox-item input[type="checkbox"]:checked + span + label {
            color: #0d9488;
        }
        
        .type-checkbox-item label {
            margin: 0;
            cursor: pointer;
            color: #333333;
        }
        
        label {
            font-size: 12px;
            color: #666666;
        }
        
        select, input[type="number"] {
            background: #ffffff;
            color: #333333;
            border: 1px solid #999;
            padding: 5px 10px;
            border-radius: 3px;
            height: 28px;
        }
        
        input[type="range"] {
            background: transparent;
            height: 28px;
        }
        
        #timeline-container {
            background: #e8e8e8;
            border-radius: 5px;
            padding: 20px;
            overflow-x: auto;
            overflow-y: auto;
            position: relative;
            max-height: calc(100vh - 200px);
        }
        
        #timeline-canvas {
            display: block;
            background: #ffffff;
        }
        
        .legend {
            background: #e8e8e8;
            padding: 15px;
            border-radius: 5px;
            margin-top: 20px;
        }
        
        .legend h3 {
            color: #0d9488;
            margin-bottom: 10px;
        }
        
        .legend-items {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 10px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 3px;
            border: 1px solid #999;
        }
        
        .legend-label {
            font-size: 12px;
        }
        
        .visualization-elements {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 15px;
            margin-top: 10px;
        }
        
        .element-item {
            display: flex;
            align-items: center;
            gap: 15px;
            padding: 10px;
            background: #ffffff;
            border-radius: 5px;
            border: 1px solid #bbb;
        }
        
        .element-visual {
            flex-shrink: 0;
            width: 50px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .element-bar {
            width: 40px;
            height: 16px;
            background: #2563eb;
            border: 1px solid #333;
            border-radius: 2px;
        }
        
        .element-desc {
            font-size: 12px;
            color: #333333;
            line-height: 1.4;
        }
        
        .element-desc strong {
            color: #0d9488;
        }
        
        .info-panel {
            background: #e8e8e8;
            padding: 15px;
            border-radius: 5px;
            margin-top: 20px;
            font-size: 12px;
            position: sticky;
            bottom: 0;
            z-index: 100;
            min-height: 50px;
            box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.12);
            width: 25%;
            max-width: 500px;
        }
        
        #info-text {
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        
        .loading {
            text-align: center;
            padding: 40px;
            color: #666666;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>NCCL Profiler Timeline Visualization</h1>
        
        <div class="controls">
            <div class="control-group">
                <label>Filter by Communicator:</label>
                <select id="commid-filter">
                    <option value="all">All Communicators</option>
                </select>
            </div>
            <div class="control-group">
                <label>Filter by Rank:</label>
                <select id="rank-filter">
                    <option value="all">All Ranks</option>
                </select>
            </div>
            <div class="control-group">
                <label>Filter by Context:</label>
                <select id="context-filter">
                    <option value="all">All Contexts</option>
                </select>
            </div>
            <div class="control-group">
                <label>Filter by Thread ID:</label>
                <select id="thread-filter">
                    <option value="all">All Threads</option>
                </select>
            </div>
            <div class="control-group">
                <label>Filter by Process ID:</label>
                <select id="pid-filter">
                    <option value="all">All Processes</option>
                </select>
            </div>
            <div class="control-group">
                <label>Filter by GPU UUID:</label>
                <select id="gpu-filter">
                    <option value="all">All GPUs</option>
                </select>
            </div>
            <div class="control-group event-type-group">
                <label>Filter by Event Type:</label>
                <div id="type-filter-checkboxes" style="display: flex; gap: 8px; flex-wrap: wrap; align-items: center;">
                    <!-- Buttons and checkboxes will be populated by JavaScript -->
                </div>
            </div>
            <div class="control-group">
                <label>Filter by CUPTI Activity Type:</label>
                <div id="cupti-type-filter-checkboxes" style="display: flex; gap: 8px; flex-wrap: wrap; align-items: center;">
                    <!-- Buttons and checkboxes will be populated by JavaScript -->
                </div>
            </div>
            <div class="control-group time-range-group">
                <label>Time Range (Î¼s):</label>
                <div>
                    <input type="number" id="time-min" placeholder="Min" step="1000">
                    <input type="number" id="time-max" placeholder="Max" step="1000">
                </div>
            </div>
            <div class="control-group">
                <label>Lane Height:</label>
                <input type="range" id="lane-height" min="20" max="100" value="40" style="width: 100px;">
            </div>
            <div class="control-group">
                <label>Zoom:</label>
                <input type="range" id="zoom" min="0.1" max="10" step="0.1" value="1" style="width: 100px;">
            </div>
            <div class="control-group checkbox-option">
                <input type="checkbox" id="show-parent-arrows" checked>
                <label for="show-parent-arrows">Show Parent-Child Arrows</label>
            </div>
            <div class="control-group checkbox-option">
                <input type="checkbox" id="show-collective-lines" checked>
                <label for="show-collective-lines">Show Collective Connections</label>
            </div>
            <div class="control-group checkbox-option">
                <input type="checkbox" id="show-profiler-lifecycle-lines" checked>
                <label for="show-profiler-lifecycle-lines">Show Profiler Lifecycle Connections</label>
            </div>
            <div class="control-group checkbox-option">
                <input type="checkbox" id="group-by-type" checked>
                <label for="group-by-type">Allow Multiple Events per Lane (same type)</label>
            </div>
            <div class="control-group checkbox-option">
                <input type="checkbox" id="normalize-time" checked>
                <label for="normalize-time">Normalize Timeline (start at 0)</label>
            </div>
            <div class="control-group checkbox-option">
                <input type="checkbox" id="show-correlation-connections" checked>
                <label for="show-correlation-connections">Show Correlation Connections</label>
            </div>
        </div>
        
        <div id="timeline-container">
            <div class="loading">Loading timeline...</div>
        </div>
        
        <div class="legend">
            <h3>Visualization Elements</h3>
            <div class="visualization-elements">
                <div class="element-item">
                    <div class="element-visual">
                        <div class="element-bar"></div>
                    </div>
                    <div class="element-desc">
                        <strong>Rectangular Bar:</strong> Event with both start and stop timestamps. Shows function name if space allows.
                    </div>
                </div>
                <div class="element-item">
                    <div class="element-visual">
                        <svg width="30" height="20" style="display: block;">
                            <polygon points="0,5 20,10 0,15" fill="#2563eb" stroke="#333" stroke-width="1"/>
                        </svg>
                    </div>
                    <div class="element-desc">
                        <strong>Right-Pointing Triangle:</strong> Event with only start timestamp (started but stop is missing).
                    </div>
                </div>
                <div class="element-item">
                    <div class="element-visual">
                        <svg width="30" height="20" style="display: block;">
                            <polygon points="20,5 0,10 20,15" fill="#2563eb" stroke="#333" stroke-width="1"/>
                        </svg>
                    </div>
                    <div class="element-desc">
                        <strong>Left-Pointing Triangle:</strong> Event with only stop timestamp (stopped but start is missing).
                    </div>
                </div>
                <div class="element-item">
                    <div class="element-visual">
                        <svg width="30" height="20" style="display: block;">
                            <circle cx="10" cy="10" r="6" fill="#2563eb" stroke="#333" stroke-width="1"/>
                        </svg>
                    </div>
                    <div class="element-desc">
                        <strong>Circle/Dot:</strong> Event that has neither start nor stop timestamp. The event exists but has no temporal duration.
                    </div>
                </div>
                <div class="element-item">
                    <div class="element-visual">
                        <svg width="30" height="20" style="display: block;" viewBox="0 -5 30 20">
                            <line x1="10" y1="0" x2="10" y2="10" stroke="#2563eb" stroke-width="2"/>
                            <circle cx="10" cy="0" r="3" fill="#b91c1c" stroke="#333" stroke-width="1"/>
                        </svg>
                    </div>
                    <div class="element-desc">
                        <strong>Small Circle Marker:</strong> State transition within event bounds (shown above the event bar).
                    </div>
                </div>
                <div class="element-item">
                    <div class="element-visual">
                        <svg width="30" height="20" style="display: block;">
                            <circle cx="10" cy="8" r="6" fill="#b91c1c" stroke="#333" stroke-width="1"/>
                            <polygon points="10,14 7,18 13,18" fill="#b91c1c" stroke="#333" stroke-width="1"/>
                        </svg>
                    </div>
                    <div class="element-desc">
                        <strong>Speech Bubble:</strong> State transition that cannot be shown as a small marker on an event bar (because the event has incomplete bounds or the state is outside the event's time range).
                    </div>
                </div>
                <div class="element-item">
                    <div class="element-visual">
                        <svg width="30" height="20" style="display: block;">
                            <line x1="5" y1="5" x2="25" y2="15" stroke="#b91c1c" stroke-width="2"/>
                        </svg>
                    </div>
                    <div class="element-desc">
                        <strong>Red Connection Line:</strong> Connects collective events (CollApi, Coll) that belong together across ranks (based on seqNum and commId).
                    </div>
                </div>
                <div class="element-item">
                    <div class="element-visual">
                        <svg width="30" height="20" style="display: block;">
                            <line x1="5" y1="5" x2="25" y2="15" stroke="#059669" stroke-width="2" stroke-dasharray="5,3"/>
                        </svg>
                    </div>
                    <div class="element-desc">
                        <strong>Green Dotted Line:</strong> Connects NCCL events to their correlated CUPTI activities (based on extCorrId - external correlation ID from CUPTI).
                    </div>
                </div>
            </div>
            <div style="margin-top: 20px; padding: 15px; background: #ffffff; border-radius: 5px; border: 1px solid #bbb;">
                <h4 style="color: #ea580c; margin-bottom: 10px;">CUPTI Activity Colors</h4>
                <div style="display: flex; gap: 20px; flex-wrap: wrap; font-size: 12px;">
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <span style="width: 20px; height: 14px; background: #ea580c; border: 1px solid #999; border-radius: 2px; display: inline-block;"></span>
                        <span>CUDA Kernels</span>
                    </div>
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <span style="width: 20px; height: 14px; background: #16a34a; border: 1px solid #999; border-radius: 2px; display: inline-block;"></span>
                        <span>Memory Copy (memcpy)</span>
                    </div>
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <span style="width: 20px; height: 14px; background: #db2777; border: 1px solid #999; border-radius: 2px; display: inline-block;"></span>
                        <span>Memory Set (memset)</span>
                    </div>
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <span style="width: 20px; height: 14px; background: #7c3aed; border: 1px solid #999; border-radius: 2px; display: inline-block;"></span>
                        <span>Other CUPTI Activities</span>
                    </div>
                </div>
            </div>
            <div style="margin-top: 20px; padding: 15px; background: #ffffff; border-radius: 5px; border: 1px solid #bbb;">
                <h4 style="color: #0d9488; margin-bottom: 10px;">About ProfilerLifecycle Events</h4>
                <div style="font-size: 12px; color: #333333; line-height: 1.6;">
                    <p><strong>ProfilerLifecycle</strong> events represent the profiler plugin's tracking period for a communicator on a specific rank:</p>
                    <ul style="margin-left: 20px; margin-top: 8px;">
                        <li><strong>profilerInit:</strong> Called for each rank when the communicator is initialized on that rank (always corresponds to comm initialization on that rank)</li>
                        <li><strong>profilerFinalize:</strong> Called for each rank when the profiler stops tracking the communicator on that rank. Always called during communicator destruction (`ncclCommDestroy`). For revoked communicators, it is called later when any communicator in the same intra-process group is destroyed.</li>
                    </ul>
                    <p style="margin-top: 8px;">The bar spans from plugin initialization to finalization, showing the period during which the profiler was actively tracking this communicator on this rank.</p>
                </div>
            </div>
        </div>
        
        <div class="info-panel">
            <div id="info-text">Hover over events to see details</div>
        </div>
    </div>
    
    <script>
        // Color palette for event types (light-theme friendly for report screenshots)
        const EVENT_COLORS = {
            'ProfilerLifecycle': '#616161',  // Grey - profiler plugin tracking period (init to finalize)
            'GroupApi': '#0d9488',
            'CollApi': '#7c3aed',
            'P2pApi': '#a855f7',
            'KernelLaunch': '#ca8a04',
            'Coll': '#a855f7',
            'P2p': '#c026d3',
            'ProxyOp': '#dc2626',
            'ProxyStep': '#dc2626',
            'ProxyCtrl': '#dc2626',
            'KernelCh': '#2563eb',
            'NetPlugin': '#2563eb',
            'Group': '#0d9488',
            'CuptiKernel': '#ea580c',    // Orange for CUDA kernels
            'CuptiMemcpy': '#16a34a',     // Green for memcpy
            'CuptiMemset': '#db2777',     // Pink for memset
            'CuptiOther': '#7c3aed',      // Purple for other CUPTI activities
            'Unknown': '#616161'
        };
        
        // Hover area expansion (in pixels) for easier hovering on small event bars
        const HOVER_EXPAND = 5;
        
        let eventsData = null;
        let filteredEvents = null;
        let canvas = null;
        let ctx = null;
        let minTime = 0;
        let maxTime = 0;
        let laneHeight = 40;
        let zoom = 1;
        let panX = 0;
        let isDragging = false;
        let dragStartX = 0;
        let hoveredEvent = null;
        let highlightedEventKey = null; // Track clicked/highlighted event by key
        let highlightedEvent = null; // Current highlighted event object (updated on render)
        let highlightedStateKey = null; // Track clicked/highlighted state's event key
        let highlightedStateIndex = null; // Track clicked/highlighted state's index within event
        let showParentArrows = true;
        let showCollectiveLines = true;
        let showProfilerLifecycleLines = true;
        // CUPTI activities are now controlled by type filter checkboxes only
        let showCorrelationConnections = true; // Default to showing correlation connections
        let groupByType = true; // Default to new mode (group by rank+type)
        let normalizeTime = true; // Default to normalized timeline (start at 0)
        let isSelecting = false;
        let selectionStartX = 0;
        let selectionEndX = 0;
        
        // Reserved width for lane labels (comm, rank, context, etc.) so event bars never overlap them
        const LABEL_WIDTH = 350;
        let timelineContentWidth = 400; // Set each render: canvas.width - LABEL_WIDTH
        
        // Helper function to normalize a timestamp (subtract global_min_time)
        function normalizeTimestamp(timestamp) {
            if (timestamp === null || timestamp === undefined) return timestamp;
            if (!normalizeTime || !eventsData || eventsData.global_min_time === undefined) {
                return timestamp;
            }
            return timestamp - eventsData.global_min_time;
        }
        
        // Helper function to denormalize a timestamp (add global_min_time)
        // Used when we have a normalized timestamp and need the absolute value
        function denormalizeTimestamp(timestamp) {
            if (timestamp === null || timestamp === undefined) return timestamp;
            if (!eventsData || eventsData.global_min_time === undefined) {
                return timestamp;
            }
            // If normalizeTime is true, inputs are normalized, so convert to absolute
            // If normalizeTime is false, inputs are already absolute, so return as-is
            if (normalizeTime) {
                return timestamp + eventsData.global_min_time;
            }
            return timestamp;
        }
        
        // Helper function to get normalized event (creates a copy with normalized timestamps)
        function getNormalizedEvent(event) {
            if (!normalizeTime || !eventsData || eventsData.global_min_time === undefined) {
                return event;
            }
            
            const normalized = { ...event };
            if (normalized.start !== null && normalized.start !== undefined) {
                normalized.start = normalizeTimestamp(normalized.start);
            }
            if (normalized.stop !== null && normalized.stop !== undefined) {
                normalized.stop = normalizeTimestamp(normalized.stop);
            }
            if (normalized.states && normalized.states.length > 0) {
                normalized.states = normalized.states.map(state => ({
                    ...state,
                    timestamp: normalizeTimestamp(state.timestamp)
                }));
            }
            return normalized;
        }
        
        // Helper function to get normalized CUPTI activity (creates a copy with normalized timestamps)
        function getNormalizedActivity(activity) {
            if (!normalizeTime || !eventsData || eventsData.global_min_time === undefined) {
                return activity;
            }
            
            const normalized = { ...activity };
            if (normalized.start !== null && normalized.start !== undefined) {
                normalized.start = normalizeTimestamp(normalized.start);
            }
            if (normalized.stop !== null && normalized.stop !== undefined) {
                normalized.stop = normalizeTimestamp(normalized.stop);
            }
            return normalized;
        }
        
        // Convert JSONL event to old format (for compatibility with existing visualization code)
        function convertJsonlEvent(jsonlEvent) {
            // Simplify type name (ncclProfileColl -> Coll)
            let type = jsonlEvent.type || 'Unknown';
            let typeName = type;
            if (type.startsWith('ncclProfile')) {
                type = type.substring('ncclProfile'.length);
            }
            
            // Convert nested start/stop structure to flat structure
            const event = {
                type: type,
                type_name: typeName,
                func: jsonlEvent.func || null,
                start: jsonlEvent.start?.ts ?? null,
                stop: jsonlEvent.stop?.ts ?? null,
                start_tid: jsonlEvent.start?.tid ?? null,
                stop_tid: jsonlEvent.stop?.tid ?? null,
                start_pid: jsonlEvent.start?.pid ?? null,
                stop_pid: jsonlEvent.stop?.pid ?? null,
                rank: jsonlEvent.rank !== undefined ? jsonlEvent.rank : null,
                commid: jsonlEvent.commId ? String(jsonlEvent.commId) : null,
                ctx: jsonlEvent.ctx || null,
                gpuUuid: jsonlEvent.gpuUuid || null,
                eventAddr: jsonlEvent.eventAddr || null,
                parentObj: jsonlEvent.parentObj || null,
                duration: jsonlEvent.duration || null,
                myPid: jsonlEvent.myPid || null,
                originPid: jsonlEvent.originPid || null,
                isPxn: jsonlEvent.isPxn || false,
                extCorrId: jsonlEvent.extCorrId || null,
                corrId: jsonlEvent.corrId || null,
                details: jsonlEvent.details || {},
                states: []
            };
            
            // Extract seq_number from details if present
            if (event.details.seq !== undefined) {
                event.seq_number = event.details.seq;
            }
            
            // Extract func from details if not present at top level
            // Some events (like CollApi, Coll) store func in details.func
            if (!event.func && event.details.func !== undefined) {
                event.func = event.details.func;
            }
            
            // Convert states array
            if (jsonlEvent.states && Array.isArray(jsonlEvent.states)) {
                event.states = jsonlEvent.states.map(state => {
                    const convertedState = {
                        timestamp: state.ts ?? null,
                        state_name: state.name || null,
                        state_id: state.id ?? null,
                        tid: state.tid ?? null,
                        pid: state.pid ?? null,
                        details: {}
                    };
                    
                    // Extract state-specific details (they're inline JSON properties)
                    // Copy all properties except the standard ones
                    for (const [key, value] of Object.entries(state)) {
                        if (!['ts', 'name', 'id', 'tid', 'pid'].includes(key)) {
                            convertedState.details[key] = value;
                        }
                    }
                    
                    return convertedState;
                });
            }
            
            return event;
        }
        
        // Convert CUPTI activity record to visualization format
        function convertCuptiActivity(cuptiRecord) {
            const type = cuptiRecord.type || 'OTHER';
            let visualType = 'CuptiOther';
            if (type === 'KERNEL') {
                visualType = 'CuptiKernel';
            } else if (type === 'MEMCPY') {
                visualType = 'CuptiMemcpy';
            } else if (type === 'MEMSET') {
                visualType = 'CuptiMemset';
            }
            
            const activity = {
                type: visualType,
                type_name: type,
                isCuptiActivity: true,
                extCorrId: cuptiRecord.extCorrId || null,
                corrId: cuptiRecord.corrId || null,
                deviceId: cuptiRecord.deviceId !== undefined ? cuptiRecord.deviceId : null,
                gpuUuid: cuptiRecord.gpuUuid || null,
                start: cuptiRecord.start?.ts ?? null,
                stop: cuptiRecord.stop?.ts ?? null,
                start_tid: cuptiRecord.start?.tid ?? null,
                stop_tid: cuptiRecord.stop?.tid ?? null,
                start_pid: cuptiRecord.start?.pid ?? null,
                stop_pid: cuptiRecord.stop?.pid ?? null,
                duration: cuptiRecord.duration || null,
                name: cuptiRecord.name || null,
                stream: cuptiRecord.stream || null,
                size: cuptiRecord.size || null,
                details: cuptiRecord.details || {}
            };
            
            return activity;
        }
        
        // Generate unique ID for an event (similar to Python parser)
        function generateEventId(event, index) {
            const eventAddr = event.eventAddr || `event_${index}`;
            const commid = event.commid || 'unknown';
            const timestamp = event.start || index;
            
            if (event.isPxn && event.originPid) {
                return `${eventAddr}_PXN_pid${event.myPid}_comm${commid}_${timestamp}`;
            } else {
                const rank = event.rank !== null && event.rank !== undefined ? event.rank : 'unknown';
                return `${eventAddr}_rank${rank}_comm${commid}_${timestamp}`;
            }
        }
        
        // Helper function to determine which event type a state belongs to based on state name
        // This prevents mismatched states from being attached to wrong events due to address reuse
        function getEventTypeForState(stateName) {
            if (!stateName) return null;
            
            // ProxyStep states belong to ncclProfileProxyStep events
            if (stateName.startsWith('ProxyStep')) {
                return 'ncclProfileProxyStep';
            }
            
            // ProxyCtrl states belong to ncclProfileProxyCtrl events
            if (stateName.startsWith('ProxyCtrl')) {
                return 'ncclProfileProxyCtrl';
            }
            
            // ProxyOp states belong to ncclProfileProxyOp events
            if (stateName.startsWith('ProxyOp')) {
                return 'ncclProfileProxyOp';
            }
            
            // NetPluginUpdate belongs to ncclProfileNetPlugin events
            if (stateName === 'NetPluginUpdate') {
                return 'ncclProfileNetPlugin';
            }
            
            // KernelChStop belongs to ncclProfileKernelCh events
            if (stateName === 'KernelChStop') {
                return 'ncclProfileKernelCh';
            }
            
            // GroupApi states belong to ncclProfileGroupApi events
            if (stateName === 'EndGroupApiStart' || stateName === 'BeginGroupApiEnd' || 
                stateName === 'GroupStartApiStop' || stateName === 'GroupEndApiStart') {
                return 'ncclProfileGroupApi';
            }
            
            return null; // Unknown state type
        }
        
        // Load events data from JSONL file
        // The JSONL format is written directly by the C++ profiler (minimal_profiler.cc)
        // Records have two types:
        //   - recordType:"event" - event records (written at STOP time)
        //   - recordType:"state" - state transition records (written immediately at STATE time)
        // State records reference their parent event via eventAddr
        async function loadEvents() {
            try {
                // Load trace.jsonl
                const jsonlResponse = await fetch('trace.jsonl');
                if (!jsonlResponse.ok) {
                    throw new Error('Could not find trace.jsonl. Run merge_traces.py to create it from per-process trace files.');
                }
                
                const jsonlText = await jsonlResponse.text();
                const lines = jsonlText.trim().split('\n').filter(line => line.trim());
                
                // Two-pass parsing:
                // Pass 1: Collect event records, state records, and CUPTI activity records separately
                const eventRecords = [];  // {recordType: "event", ...}
                const stateRecords = [];  // {recordType: "state", eventAddr: "0x...", ...}
                const cuptiActivityRecords = [];  // {recordType: "cuptiActivity", ...}
                
                let errorCount = 0;
                let nonJsonCount = 0;
                let parseErrorCount = 0;
                
                lines.forEach((line, index) => {
                    const trimmedLine = line.trim();
                    
                    // Skip empty lines silently
                    if (!trimmedLine) return;
                    
                    // Log non-JSON lines
                    if (!trimmedLine.startsWith('{')) {
                        nonJsonCount++;
                        console.error(`Line ${index + 1}: Does not start with '{' - ${trimmedLine}`);
                        return;
                    }
                    
                    try {
                        const record = JSON.parse(trimmedLine);
                        if (record.recordType === 'state') {
                            stateRecords.push(record);
                        } else if (record.recordType === 'cuptiActivity') {
                            cuptiActivityRecords.push({record, index});
                        } else if (record.recordType === 'event' || record.type) {
                            // Event record (recordType:"event" or has type field)
                            eventRecords.push({record, index});
                        }
                    } catch (e) {
                        parseErrorCount++;
                        errorCount++;
                        console.error(`Line ${index + 1}: JSON parse error - ${e.message}`);
                        console.error(`  Content: ${trimmedLine}`);
                    }
                });
                
                // Log summary
                if (nonJsonCount > 0 || parseErrorCount > 0) {
                    console.error(`\n=== JSONL Parsing Errors Summary ===`);
                    console.error(`Total lines processed: ${lines.length}`);
                    console.error(`Non-JSON lines (not starting with '{'): ${nonJsonCount}`);
                    console.error(`JSON parse errors: ${parseErrorCount}`);
                    console.error(`Total errors: ${nonJsonCount + parseErrorCount}`);
                    console.error(`Successfully parsed: ${eventRecords.length} events, ${stateRecords.length} states, ${cuptiActivityRecords.length} CUPTI activities`);
                }
                
                // Group states by eventAddr for fast lookup
                const statesByEventAddr = new Map();
                stateRecords.forEach(state => {
                    if (state.eventAddr) {
                        if (!statesByEventAddr.has(state.eventAddr)) {
                            statesByEventAddr.set(state.eventAddr, []);
                        }
                        statesByEventAddr.get(state.eventAddr).push(state);
                    }
                });
                
                // Pass 2: Convert events and CUPTI activities, attach states
                const events = {};
                const cuptiActivities = {};
                const ranks = new Set();
                const contexts = new Set();
                const threads = new Set();
                const pids = new Set();
                const commids = new Set();
                const gpuUuids = new Set();
                const deviceIds = new Set();
                
                // Correlation maps: extCorrId -> arrays of event/activity keys
                const extCorrIdToNcclEvents = new Map();
                const extCorrIdToCuptiActivities = new Map();
                
                // Statistics for state attachment
                let eventsWithStates = 0;
                let totalStatesAttached = 0;
                
                eventRecords.forEach(({record, index}) => {
                    // Attach separate state records to this event before conversion
                    // States are written as separate JSONL records with recordType:"state"
                    // and reference their parent event via eventAddr
                    const eventAddr = record.eventAddr;
                    if (eventAddr && statesByEventAddr.has(eventAddr)) {
                        // Get event type and time bounds for filtering
                        // This handles address reuse - same eventAddr might be used by multiple events
                        const eventType = record.type || null;
                        const eventStart = record.start?.ts ?? null;
                        const eventStop = record.stop?.ts ?? null;
                        
                        // Filter states by both type and timestamp to handle address reuse
                        let candidateStates = statesByEventAddr.get(eventAddr);
                        
                        // First, filter by event type - states must belong to the correct event type
                        if (eventType) {
                            candidateStates = candidateStates.filter(s => {
                                const expectedEventType = getEventTypeForState(s.name);
                                // If we can determine the expected event type, it must match
                                // If we can't determine it (null), allow it (unknown states)
                                return expectedEventType === null || expectedEventType === eventType;
                            });
                        }
                        
                        // Then, filter by timestamp if event has both start and stop
                        if (eventStart !== null && eventStop !== null) {
                            // Event has both start and stop - filter states within this range
                            candidateStates = candidateStates.filter(s => {
                                const stateTime = s.ts || 0;
                                return stateTime >= eventStart && stateTime <= eventStop;
                            });
                        }
                        // If event has incomplete bounds (only start or only stop, or neither),
                        // we rely on type-based filtering only to avoid false matches
                        
                        // Sort states by timestamp and convert to event format
                        const states = candidateStates
                            .sort((a, b) => (a.ts || 0) - (b.ts || 0))
                            .map(s => ({
                                ts: s.ts,
                                name: s.name,
                                id: s.id,
                                tid: s.tid,
                                pid: s.pid,
                                // Copy extra fields (transSize, appendedProxyOps, etc.)
                                ...Object.fromEntries(
                                    Object.entries(s).filter(([k]) => 
                                        !['recordType', 'eventAddr', 'ts', 'name', 'id', 'tid', 'pid'].includes(k)
                                    )
                                )
                            }));
                        record.states = states;
                        if (states.length > 0) {
                            eventsWithStates++;
                            totalStatesAttached += states.length;
                        }
                    } else {
                        record.states = [];
                    }
                    
                    const event = convertJsonlEvent(record);
                    const eventId = generateEventId(event, index);
                    
                    events[eventId] = event;
                    
                    // Collect metadata
                    if (event.rank !== null && event.rank !== undefined) ranks.add(event.rank);
                    if (event.ctx) contexts.add(event.ctx);
                    if (event.start_tid !== null) threads.add(event.start_tid);
                    if (event.stop_tid !== null) threads.add(event.stop_tid);
                    if (event.start_pid !== null) pids.add(event.start_pid);
                    if (event.stop_pid !== null) pids.add(event.stop_pid);
                    if (event.commid) commids.add(event.commid);
                    if (event.gpuUuid) gpuUuids.add(event.gpuUuid);
                    event.states.forEach(state => {
                        if (state.tid !== null) threads.add(state.tid);
                        if (state.pid !== null) pids.add(state.pid);
                    });
                    
                    // Track extCorrId for correlation mapping (with PID for process-specific matching)
                    if (event.extCorrId !== undefined && event.extCorrId !== null) {
                        // Use composite key: extCorrId + pid (use start_pid, fallback to stop_pid)
                        const pid = event.start_pid !== null && event.start_pid !== undefined 
                            ? event.start_pid 
                            : (event.stop_pid !== null && event.stop_pid !== undefined ? event.stop_pid : null);
                        const correlationKey = pid !== null ? `${event.extCorrId}_${pid}` : String(event.extCorrId);
                        if (!extCorrIdToNcclEvents.has(correlationKey)) {
                            extCorrIdToNcclEvents.set(correlationKey, []);
                        }
                        extCorrIdToNcclEvents.get(correlationKey).push(eventId);
                    }
                });
                
                // Process CUPTI activities
                cuptiActivityRecords.forEach(({record, index}) => {
                    const activity = convertCuptiActivity(record);
                    // Generate unique ID for CUPTI activity
                    const activityId = `cupti_${activity.deviceId}_${activity.type_name}_${activity.start || index}_${index}`;
                    
                    cuptiActivities[activityId] = activity;
                    
                    // Collect metadata
                    if (activity.deviceId !== null) deviceIds.add(activity.deviceId);
                    if (activity.gpuUuid) gpuUuids.add(activity.gpuUuid);
                    if (activity.start_tid !== null) threads.add(activity.start_tid);
                    if (activity.stop_tid !== null) threads.add(activity.stop_tid);
                    if (activity.start_pid !== null) pids.add(activity.start_pid);
                    if (activity.stop_pid !== null) pids.add(activity.stop_pid);
                    
                    // Track extCorrId for correlation mapping (with PID for process-specific matching)
                    if (activity.extCorrId !== undefined && activity.extCorrId !== null) {
                        // Use composite key: extCorrId + pid (use start_pid, fallback to stop_pid)
                        const pid = activity.start_pid !== null && activity.start_pid !== undefined 
                            ? activity.start_pid 
                            : (activity.stop_pid !== null && activity.stop_pid !== undefined ? activity.stop_pid : null);
                        const correlationKey = pid !== null ? `${activity.extCorrId}_${pid}` : String(activity.extCorrId);
                        if (!extCorrIdToCuptiActivities.has(correlationKey)) {
                            extCorrIdToCuptiActivities.set(correlationKey, []);
                        }
                        extCorrIdToCuptiActivities.get(correlationKey).push(activityId);
                    }
                });
                
                console.log(`Loaded ${eventRecords.length} events, ${stateRecords.length} state records, and ${cuptiActivityRecords.length} CUPTI activities`);
                console.log(`State attachment: ${eventsWithStates} events have states (${totalStatesAttached} total states attached)`);
                
                // Check for orphan states (states without eventAddr) and unmatched states
                const orphanStates = stateRecords.filter(s => !s.eventAddr);
                if (orphanStates.length > 0) {
                    console.warn(`Warning: ${orphanStates.length} state records have no eventAddr and were not attached to any event`);
                }
                
                // Check for states that reference events that don't exist
                const unmatchedStateAddrs = new Set();
                statesByEventAddr.forEach((states, eventAddr) => {
                    // Check if any event has this eventAddr
                    const hasMatchingEvent = eventRecords.some(({record}) => record.eventAddr === eventAddr);
                    if (!hasMatchingEvent) {
                        unmatchedStateAddrs.add(eventAddr);
                    }
                });
                if (unmatchedStateAddrs.size > 0) {
                    console.warn(`Warning: ${unmatchedStateAddrs.size} event addresses referenced by states don't match any event:`, Array.from(unmatchedStateAddrs).slice(0, 10));
                }
                
                // Build parent-child maps from parentObj
                const eventByAddr = new Map();
                Object.entries(events).forEach(([key, event]) => {
                    if (event.eventAddr) {
                        if (!eventByAddr.has(event.eventAddr)) {
                            eventByAddr.set(event.eventAddr, []);
                        }
                        eventByAddr.get(event.eventAddr).push({key, event});
                    }
                });
                
                const parent_child_map = {};
                const event_to_parent = {};
                
                Object.entries(events).forEach(([key, event]) => {
                    if (event.parentObj && event.parentObj !== 'null' && event.parentObj !== null) {
                        // Find parent event(s) with matching eventAddr
                        const candidates = eventByAddr.get(event.parentObj) || [];
                        
                        if (candidates.length > 0) {
                            // Filter to valid parents (started before or at child start time)
                            const childStart = event.start;
                            const validParents = candidates
                                .filter(({event: parentEvent}) => {
                                    if (parentEvent.start === null) return false;
                                    if (childStart === null) return true;
                                    return parentEvent.start <= childStart;
                                })
                                .sort((a, b) => (b.event.start || 0) - (a.event.start || 0)); // Most recent first
                            
                            if (validParents.length > 0) {
                                const parent = validParents[0];
                                event_to_parent[key] = parent.key;
                                if (!parent_child_map[parent.key]) {
                                    parent_child_map[parent.key] = [];
                                }
                                parent_child_map[parent.key].push(key);
                            }
                        }
                    }
                });
                
                // Build eventsData structure
                eventsData = {
                    events: events,
                    cuptiActivities: cuptiActivities,
                    ranks: Array.from(ranks).sort((a, b) => a - b),
                    contexts: Array.from(contexts).sort(),
                    threads: Array.from(threads).sort((a, b) => a - b),
                    pids: Array.from(pids).sort((a, b) => a - b),
                    commids: Array.from(commids).sort(),
                    gpuUuids: Array.from(gpuUuids).sort(),
                    deviceIds: Array.from(deviceIds).sort((a, b) => a - b),
                    extCorrIdToNcclEvents: extCorrIdToNcclEvents,
                    extCorrIdToCuptiActivities: extCorrIdToCuptiActivities,
                    parent_child_map: parent_child_map,
                    event_to_parent: event_to_parent,
                    total_events: Object.keys(events).length,
                    total_cupti_activities: Object.keys(cuptiActivities).length
                };
                
                // Calculate global_min_time from events
                calculateGlobalMinTime();
                
                initializeFilters();
                applyFilters(); // This will set filteredEvents and render the timeline
            } catch (error) {
                document.getElementById('timeline-container').innerHTML = 
                    '<div class="loading" style="color: #dc2626;">Error loading trace.jsonl: ' + error.message + '</div>';
                console.error('Error loading events:', error);
            }
        }
        
        // Calculate global minimum timestamp from all events and CUPTI activities
        // This makes the visualizer self-contained - it doesn't need parse_logs.py to pre-calculate this
        function calculateGlobalMinTime() {
            let minTimestamp = Infinity;
            
            for (const [key, event] of Object.entries(eventsData.events || {})) {
                if (event.start !== null && event.start !== undefined) {
                    minTimestamp = Math.min(minTimestamp, event.start);
                }
                if (event.stop !== null && event.stop !== undefined) {
                    minTimestamp = Math.min(minTimestamp, event.stop);
                }
                if (event.states) {
                    event.states.forEach(state => {
                        if (state.timestamp !== null && state.timestamp !== undefined) {
                            minTimestamp = Math.min(minTimestamp, state.timestamp);
                        }
                    });
                }
            }
            
            // Include CUPTI activities in time calculation
            for (const [key, activity] of Object.entries(eventsData.cuptiActivities || {})) {
                if (activity.start !== null && activity.start !== undefined) {
                    minTimestamp = Math.min(minTimestamp, activity.start);
                }
                if (activity.stop !== null && activity.stop !== undefined) {
                    minTimestamp = Math.min(minTimestamp, activity.stop);
                }
            }
            
            // Store calculated value (overrides any value from parser)
            eventsData.global_min_time = minTimestamp !== Infinity ? minTimestamp : 0;
            
            console.log(`Calculated global_min_time: ${eventsData.global_min_time.toFixed(2)}Î¼s`);
        }
        
        function initializeFilters() {
            const rankFilter = document.getElementById('rank-filter');
            const contextFilter = document.getElementById('context-filter');
            const threadFilter = document.getElementById('thread-filter');
            const pidFilter = document.getElementById('pid-filter');
            const typeFilterContainer = document.getElementById('type-filter-checkboxes');
            
            // Populate rank filter
            // If ranks array is empty, try to extract from events
            let ranks = eventsData.ranks || [];
            if (ranks.length === 0) {
                const rankSet = new Set();
                Object.values(eventsData.events || {}).forEach(event => {
                    if (event.rank !== undefined && event.rank !== null) {
                        rankSet.add(event.rank);
                    }
                });
                ranks = Array.from(rankSet).sort((a, b) => a - b);
            }
            ranks.forEach(rank => {
                const option = document.createElement('option');
                option.value = rank;
                option.textContent = `Rank ${rank}`;
                rankFilter.appendChild(option);
            });
            
            // Populate context filter
            eventsData.contexts.forEach(ctx => {
                const option = document.createElement('option');
                option.value = ctx;
                option.textContent = `Context ${ctx}`;
                contextFilter.appendChild(option);
            });
            
            // Populate thread filter
            if (eventsData.threads && eventsData.threads.length > 0) {
                eventsData.threads.forEach(tid => {
                    const option = document.createElement('option');
                    option.value = tid;
                    option.textContent = `Thread ${tid}`;
                    threadFilter.appendChild(option);
                });
            }
            
            // Populate process ID filter
            // If pids array is empty, try to extract from events
            let pids = eventsData.pids || [];
            if (pids.length === 0) {
                const pidSet = new Set();
                Object.values(eventsData.events || {}).forEach(event => {
                    if (event.start_pid !== undefined && event.start_pid !== null) {
                        pidSet.add(event.start_pid);
                    }
                    if (event.stop_pid !== undefined && event.stop_pid !== null) {
                        pidSet.add(event.stop_pid);
                    }
                    if (event.states) {
                        event.states.forEach(state => {
                            if (state.pid !== undefined && state.pid !== null) {
                                pidSet.add(state.pid);
                            }
                        });
                    }
                });
                pids = Array.from(pidSet).sort((a, b) => a - b);
            }
            if (pids.length > 0) {
                pids.forEach(pid => {
                    const option = document.createElement('option');
                    option.value = pid;
                    option.textContent = `Process ${pid}`;
                    pidFilter.appendChild(option);
                });
            }
            
            // Populate GPU UUID filter
            const gpuFilter = document.getElementById('gpu-filter');
            let gpuUuids = eventsData.gpuUuids || [];
            if (gpuUuids.length === 0) {
                const gpuSet = new Set();
                Object.values(eventsData.events || {}).forEach(event => {
                    if (event.gpuUuid) {
                        gpuSet.add(event.gpuUuid);
                    }
                });
                gpuUuids = Array.from(gpuSet).sort();
            }
            if (gpuUuids.length > 0) {
                gpuUuids.forEach(gpuUuid => {
                    const option = document.createElement('option');
                    option.value = gpuUuid;
                    // Show shortened UUID for readability
                    const shortUuid = gpuUuid.length > 20 ? gpuUuid.substring(0, 20) + '...' : gpuUuid;
                    option.textContent = shortUuid;
                    gpuFilter.appendChild(option);
                });
            }
            
            // Populate Device ID filter (for CUPTI activities)
            const deviceFilter = document.getElementById('device-filter');
            if (!deviceFilter) {
                // Create device filter if it doesn't exist
                const controls = document.querySelector('.controls');
                const deviceFilterGroup = document.createElement('div');
                deviceFilterGroup.className = 'control-group';
                deviceFilterGroup.innerHTML = '<label>Filter by GPU Device ID:</label><select id="device-filter"><option value="all">All Devices</option></select>';
                controls.appendChild(deviceFilterGroup);
            }
            const deviceFilterSelect = document.getElementById('device-filter');
            const deviceIds = eventsData.deviceIds || [];
            if (deviceIds.length > 0) {
                deviceIds.forEach(deviceId => {
                    const option = document.createElement('option');
                    option.value = deviceId;
                    option.textContent = `Device ${deviceId}`;
                    deviceFilterSelect.appendChild(option);
                });
            }
            
            // Populate communicator filter
            const commidFilter = document.getElementById('commid-filter');
            // If commids array is empty, try to extract from events
            let commids = eventsData.commids || [];
            if (commids.length === 0) {
                const commidSet = new Set();
                Object.values(eventsData.events || {}).forEach(event => {
                    if (event.commid && event.commid !== 'unknown') {
                        commidSet.add(event.commid);
                    }
                });
                commids = Array.from(commidSet).sort();
                // Also store back so other code can use it
                eventsData.commids = commids;
            }
            if (commids.length > 0) {
                commids.forEach((commid, idx) => {
                    const option = document.createElement('option');
                    option.value = commid;
                    // Show shortened commid with index for readability
                    const shortId = commid.length > 8 ? commid.slice(-8) : commid;
                    option.textContent = `Comm #${idx + 1} (...${shortId})`;
                    commidFilter.appendChild(option);
                });
            }
            
            // Populate type filter with checkboxes
            const types = new Set();
            Object.values(eventsData.events).forEach(event => {
                if (event.type) types.add(event.type);
            });
            
            // Add "Select All" / "Deselect All" buttons with same styling as checkboxes
            const selectAllBtn = document.createElement('button');
            selectAllBtn.textContent = 'All';
            selectAllBtn.className = 'type-filter-btn';
            selectAllBtn.onclick = () => {
                Array.from(typeFilterContainer.querySelectorAll('input[type="checkbox"]')).forEach(cb => cb.checked = true);
                applyFilters();
            };
            typeFilterContainer.appendChild(selectAllBtn);
            
            const deselectAllBtn = document.createElement('button');
            deselectAllBtn.textContent = 'None';
            deselectAllBtn.className = 'type-filter-btn';
            deselectAllBtn.onclick = () => {
                Array.from(typeFilterContainer.querySelectorAll('input[type="checkbox"]')).forEach(cb => cb.checked = false);
                applyFilters();
            };
            typeFilterContainer.appendChild(deselectAllBtn);
            
            // Add checkboxes for each event type
            // Sort types: ProfilerLifecycle first, then alphabetically
            const sortedTypes = Array.from(types).sort((a, b) => {
                // ProfilerLifecycle always goes first
                if (a === 'ProfilerLifecycle' && b !== 'ProfilerLifecycle') return -1;
                if (a !== 'ProfilerLifecycle' && b === 'ProfilerLifecycle') return 1;
                
                // Otherwise sort alphabetically
                return a.localeCompare(b);
            });
            sortedTypes.forEach(type => {
                const checkboxItem = document.createElement('div');
                checkboxItem.className = 'type-checkbox-item';
                
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = `type-filter-${type}`;
                checkbox.value = type;
                checkbox.checked = true; // All checked by default
                checkbox.addEventListener('change', applyFilters);
                
                const label = document.createElement('label');
                label.htmlFor = `type-filter-${type}`;
                label.textContent = type;
                
                // Add color indicator
                const colorBox = document.createElement('span');
                colorBox.style.cssText = `width: 12px; height: 12px; background: ${EVENT_COLORS[type] || EVENT_COLORS['Unknown']}; border: 1px solid #999; border-radius: 2px; display: inline-block;`;
                
                checkboxItem.appendChild(checkbox);
                checkboxItem.appendChild(colorBox);
                checkboxItem.appendChild(label);
                
                // Make the entire box clickable (including color indicator)
                checkboxItem.addEventListener('click', (e) => {
                    // Don't toggle if clicking directly on the checkbox or label
                    // (checkbox handles its own toggle, label uses htmlFor to toggle)
                    if (e.target !== checkbox && e.target !== label) {
                        checkbox.checked = !checkbox.checked;
                        applyFilters();
                    }
                });
                
                typeFilterContainer.appendChild(checkboxItem);
            });
            
            // Populate CUPTI activity type filter with checkboxes
            const cuptiTypeFilterContainer = document.getElementById('cupti-type-filter-checkboxes');
            if (cuptiTypeFilterContainer) {
                const cuptiTypes = new Set();
                if (eventsData.cuptiActivities) {
                    Object.values(eventsData.cuptiActivities).forEach(activity => {
                        if (activity.type) cuptiTypes.add(activity.type);
                    });
                }
                
                // Add "Select All" / "Deselect All" buttons
                const cuptiSelectAllBtn = document.createElement('button');
                cuptiSelectAllBtn.textContent = 'All';
                cuptiSelectAllBtn.className = 'type-filter-btn';
                cuptiSelectAllBtn.onclick = () => {
                    Array.from(cuptiTypeFilterContainer.querySelectorAll('input[type="checkbox"]')).forEach(cb => cb.checked = true);
                    applyFilters();
                };
                cuptiTypeFilterContainer.appendChild(cuptiSelectAllBtn);
                
                const cuptiDeselectAllBtn = document.createElement('button');
                cuptiDeselectAllBtn.textContent = 'None';
                cuptiDeselectAllBtn.className = 'type-filter-btn';
                cuptiDeselectAllBtn.onclick = () => {
                    Array.from(cuptiTypeFilterContainer.querySelectorAll('input[type="checkbox"]')).forEach(cb => cb.checked = false);
                    applyFilters();
                };
                cuptiTypeFilterContainer.appendChild(cuptiDeselectAllBtn);
                
                // Add checkboxes for each CUPTI activity type
                // Define the order: KERNEL, MEMCPY, MEMSET, OTHER
                const cuptiTypeOrder = ['CuptiKernel', 'CuptiMemcpy', 'CuptiMemset', 'CuptiOther'];
                const sortedCuptiTypes = Array.from(cuptiTypes).sort((a, b) => {
                    const aIndex = cuptiTypeOrder.indexOf(a);
                    const bIndex = cuptiTypeOrder.indexOf(b);
                    if (aIndex !== -1 && bIndex !== -1) return aIndex - bIndex;
                    if (aIndex !== -1) return -1;
                    if (bIndex !== -1) return 1;
                    return a.localeCompare(b);
                });
                
                sortedCuptiTypes.forEach(type => {
                    const checkboxItem = document.createElement('div');
                    checkboxItem.className = 'type-checkbox-item';
                    
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.id = `cupti-type-filter-${type}`;
                    checkbox.value = type;
                    checkbox.checked = true; // All checked by default
                    checkbox.addEventListener('change', applyFilters);
                    
                    const label = document.createElement('label');
                    label.htmlFor = `cupti-type-filter-${type}`;
                    // Display user-friendly name
                    const displayName = type.replace('Cupti', '');
                    label.textContent = displayName;
                    
                    // Add color indicator
                    const colorBox = document.createElement('span');
                    colorBox.style.cssText = `width: 12px; height: 12px; background: ${EVENT_COLORS[type] || EVENT_COLORS['Unknown']}; border: 1px solid #999; border-radius: 2px; display: inline-block;`;
                    
                    checkboxItem.appendChild(checkbox);
                    checkboxItem.appendChild(colorBox);
                    checkboxItem.appendChild(label);
                    
                    // Make the entire box clickable
                    checkboxItem.addEventListener('click', (e) => {
                        if (e.target !== checkbox && e.target !== label) {
                            checkbox.checked = !checkbox.checked;
                            applyFilters();
                        }
                    });
                    
                    cuptiTypeFilterContainer.appendChild(checkboxItem);
                });
            }
            
            // Setup event listeners
            rankFilter.addEventListener('change', applyFilters);
            contextFilter.addEventListener('change', applyFilters);
            threadFilter.addEventListener('change', applyFilters);
            pidFilter.addEventListener('change', applyFilters);
            commidFilter.addEventListener('change', applyFilters);
            document.getElementById('gpu-filter').addEventListener('change', applyFilters);
            // Type filter checkboxes already have event listeners attached above
            document.getElementById('time-min').addEventListener('input', applyFilters);
            document.getElementById('time-max').addEventListener('input', applyFilters);
            document.getElementById('lane-height').addEventListener('input', (e) => {
                laneHeight = parseInt(e.target.value);
                renderTimeline();
            });
            document.getElementById('zoom').addEventListener('input', (e) => {
                zoom = parseFloat(e.target.value);
                renderTimeline();
            });
            document.getElementById('show-parent-arrows').addEventListener('change', (e) => {
                showParentArrows = e.target.checked;
                renderTimeline();
            });
            document.getElementById('show-collective-lines').addEventListener('change', (e) => {
                showCollectiveLines = e.target.checked;
                renderTimeline();
            });
            document.getElementById('show-profiler-lifecycle-lines').addEventListener('change', (e) => {
                showProfilerLifecycleLines = e.target.checked;
                renderTimeline();
            });
            document.getElementById('group-by-type').addEventListener('change', (e) => {
                groupByType = e.target.checked;
                renderTimeline();
            });
            document.getElementById('normalize-time').addEventListener('change', (e) => {
                const wasNormalized = normalizeTime;
                normalizeTime = e.target.checked;
                
                // Convert current time range inputs to maintain the same slice
                const timeMinInput = document.getElementById('time-min');
                const timeMaxInput = document.getElementById('time-max');
                const currentMin = parseFloat(timeMinInput.value) || null;
                const currentMax = parseFloat(timeMaxInput.value) || null;
                
                if (eventsData && eventsData.global_min_time !== undefined) {
                    const offset = eventsData.global_min_time;
                    
                    if (currentMin !== null) {
                        if (wasNormalized && !normalizeTime) {
                            // Converting from normalized to absolute: add offset
                            timeMinInput.value = Math.round(currentMin + offset);
                        } else if (!wasNormalized && normalizeTime) {
                            // Converting from absolute to normalized: subtract offset
                            timeMinInput.value = Math.round(currentMin - offset);
                        }
                    }
                    
                    if (currentMax !== null) {
                        if (wasNormalized && !normalizeTime) {
                            // Converting from normalized to absolute: add offset
                            timeMaxInput.value = Math.round(currentMax + offset);
                        } else if (!wasNormalized && normalizeTime) {
                            // Converting from absolute to normalized: subtract offset
                            timeMaxInput.value = Math.round(currentMax - offset);
                        }
                    }
                }
                
                applyFilters();
            });
            document.getElementById('show-correlation-connections').addEventListener('change', (e) => {
                showCorrelationConnections = e.target.checked;
                renderTimeline();
            });
            // deviceFilterSelect was already declared earlier in initializeFilters() - just add event listener
            if (deviceFilterSelect) {
                deviceFilterSelect.addEventListener('change', applyFilters);
            }
        }
        
        function applyFilters() {
            const rankFilter = document.getElementById('rank-filter').value;
            const contextFilter = document.getElementById('context-filter').value;
            const threadFilter = document.getElementById('thread-filter').value;
            const pidFilter = document.getElementById('pid-filter').value;
            const commidFilter = document.getElementById('commid-filter').value;
            const gpuFilter = document.getElementById('gpu-filter').value;
            const deviceFilter = document.getElementById('device-filter') ? document.getElementById('device-filter').value : 'all';
            let timeMin = parseFloat(document.getElementById('time-min').value) || null;
            let timeMax = parseFloat(document.getElementById('time-max').value) || null;
            
            // Convert time filter inputs to absolute time for comparison with raw events
            // If normalization is enabled, the inputs are in normalized time, so convert to absolute
            if (normalizeTime && eventsData && eventsData.global_min_time !== undefined) {
                if (timeMin !== null) {
                    timeMin = denormalizeTimestamp(timeMin);
                }
                if (timeMax !== null) {
                    timeMax = denormalizeTimestamp(timeMax);
                }
            }
            
            // Get selected event types from checkboxes
            const selectedTypes = new Set();
            const typeFilterContainer = document.getElementById('type-filter-checkboxes');
            const hasTypeFilter = typeFilterContainer && typeFilterContainer.querySelectorAll('input[type="checkbox"]').length > 0;
            typeFilterContainer?.querySelectorAll('input[type="checkbox"]:checked').forEach(checkbox => {
                selectedTypes.add(checkbox.value);
            });
            
            // Get selected CUPTI activity types from checkboxes
            const selectedCuptiTypes = new Set();
            const cuptiTypeFilterContainer = document.getElementById('cupti-type-filter-checkboxes');
            const hasCuptiTypeFilter = cuptiTypeFilterContainer && cuptiTypeFilterContainer.querySelectorAll('input[type="checkbox"]').length > 0;
            cuptiTypeFilterContainer?.querySelectorAll('input[type="checkbox"]:checked').forEach(checkbox => {
                selectedCuptiTypes.add(checkbox.value);
            });
            
            // Filter NCCL events using absolute timestamps
            filteredEvents = Object.entries(eventsData.events).filter(([key, event]) => {
                if (rankFilter !== 'all' && event.rank !== parseInt(rankFilter)) return false;
                if (contextFilter !== 'all' && event.ctx !== contextFilter) return false;
                
                // Thread filter: match if start_tid, stop_tid, or any state tid matches
                if (threadFilter !== 'all') {
                    const tid = parseInt(threadFilter);
                    const hasMatchingTid = 
                        event.start_tid === tid || 
                        event.stop_tid === tid ||
                        (event.states && event.states.some(s => s.tid === tid));
                    if (!hasMatchingTid) return false;
                }
                
                // Process ID filter: match if start_pid, stop_pid, or any state pid matches
                if (pidFilter !== 'all') {
                    const pid = parseInt(pidFilter);
                    const hasMatchingPid = 
                        event.start_pid === pid || 
                        event.stop_pid === pid ||
                        (event.states && event.states.some(s => s.pid === pid));
                    if (!hasMatchingPid) return false;
                }
                
                // Communicator filter
                if (commidFilter !== 'all' && event.commid !== commidFilter) return false;
                
                // GPU UUID filter
                if (gpuFilter !== 'all' && event.gpuUuid !== gpuFilter) return false;
                
                // Type filter: if filter exists and nothing is selected, hide all; if something is selected, show only selected
                if (hasTypeFilter) {
                    if (selectedTypes.size === 0 || !selectedTypes.has(event.type)) return false;
                }
                
                // Time filtering: compare against absolute timestamps
                if (timeMin !== null && event.stop !== null && event.stop < timeMin) return false;
                if (timeMax !== null && event.start !== null && event.start > timeMax) return false;
                return true;
            }).map(([key, event]) => {
                // Return normalized event for display
                return [key, getNormalizedEvent(event)];
            });
            
            // Filter and add CUPTI activities (controlled by type filter checkboxes)
            if (eventsData.cuptiActivities) {
                const filteredActivities = Object.entries(eventsData.cuptiActivities).filter(([key, activity]) => {
                    // Type filter for CUPTI activities: if filter exists and nothing is selected, hide all; if something is selected, show only selected
                    if (hasCuptiTypeFilter) {
                        if (selectedCuptiTypes.size === 0 || !selectedCuptiTypes.has(activity.type)) return false;
                    }
                    
                    // Device filter
                    if (deviceFilter !== 'all' && activity.deviceId !== parseInt(deviceFilter)) return false;
                    
                    // Thread filter for CUPTI activities
                    if (threadFilter !== 'all') {
                        const tid = parseInt(threadFilter);
                        const hasMatchingTid = 
                            activity.start_tid === tid || 
                            activity.stop_tid === tid;
                        if (!hasMatchingTid) return false;
                    }
                    
                    // Process ID filter for CUPTI activities
                    if (pidFilter !== 'all') {
                        const pid = parseInt(pidFilter);
                        const hasMatchingPid = 
                            activity.start_pid === pid || 
                            activity.stop_pid === pid;
                        if (!hasMatchingPid) return false;
                    }
                    
                    // Time filtering: compare against absolute timestamps
                    if (timeMin !== null && activity.stop !== null && activity.stop < timeMin) return false;
                    if (timeMax !== null && activity.start !== null && activity.start > timeMax) return false;
                    return true;
                }).map(([key, activity]) => {
                    // Return normalized activity for display
                    return [key, getNormalizedActivity(activity)];
                });
                
                // Append CUPTI activities to filteredEvents
                filteredEvents = filteredEvents.concat(filteredActivities);
            }
            
            renderTimeline();
        }
        
        function calculateTimeRange() {
            minTime = Infinity;
            maxTime = -Infinity;
            
            filteredEvents.forEach(([key, event]) => {
                if (event.start !== null) {
                    minTime = Math.min(minTime, event.start);
                    maxTime = Math.max(maxTime, event.start);
                }
                if (event.stop !== null) {
                    minTime = Math.min(minTime, event.stop);
                    maxTime = Math.max(maxTime, event.stop);
                }
                // CUPTI activities don't have states, so check before iterating
                if (event.states && event.states.length > 0) {
                    event.states.forEach(state => {
                        minTime = Math.min(minTime, state.timestamp);
                        maxTime = Math.max(maxTime, state.timestamp);
                    });
                }
            });
            
            if (minTime === Infinity) {
                minTime = 0;
                maxTime = 1000;
            }
            
            // Add padding
            const padding = (maxTime - minTime) * 0.1;
            minTime -= padding;
            maxTime += padding;
        }
        
        // Helper function to get event time bounds (already normalized if normalizeTime is true)
        function getEventBounds(event) {
            const hasStates = event.states && event.states.length > 0;
            const eventStart = event.start !== null ? event.start : 
                (event.stop !== null ? event.stop - 1000 : 
                (hasStates ? event.states[0].timestamp - 1000 : 0));
            const eventEnd = event.stop !== null ? event.stop : 
                (event.start !== null ? event.start + 1000 : 
                (hasStates ? event.states[event.states.length - 1].timestamp + 1000 : eventStart + 1000));
            return { start: eventStart, end: eventEnd };
        }
        
        // Helper function to check if two events overlap
        function eventsOverlap(event1, event2) {
            const bounds1 = getEventBounds(event1);
            const bounds2 = getEventBounds(event2);
            return !(bounds1.end < bounds2.start || bounds1.start > bounds2.end);
        }
        
        // Preferred event type order for lane organization
        function getEventTypePriority(eventType) {
            const priorityOrder = [
                'ProfilerLifecycle',  // Profiler lifecycle events first
                'GroupApi',
                'CollApi',
                'P2pApi',
                'KernelLaunch',
                'Group',
                'Coll',
                'P2p',
                'ProxyCtrl',
                'ProxyOp',
                'ProxyStep',
                'NetPlugin',
                'KernelCh'
            ];
            const index = priorityOrder.indexOf(eventType);
            // If type not in priority list, put it at the end (high priority number)
            return index !== -1 ? index : priorityOrder.length;
        }
        
        function organizeLanesByType() {
            // Group events by communicator, rank and event type, then assign lanes within each group
            // Events of the same communicator && same rank && same type && non-overlapping go on the same lane
            // Concurrent events (overlapping) go on different lanes
            // When a new event comes after concurrent events, prefer the first lane of that type
            // Lanes are ordered by communicator first, then rank, then by preferred event type order
            // CUPTI activities are grouped by device ID and type
            const lanes = [];
            const eventToLane = new Map();
            const activityToLane = new Map();
            
            // Separate NCCL events and CUPTI activities
            const ncclEvents = [];
            const cuptiActivities = [];
            filteredEvents.forEach(([key, item]) => {
                if (item.isCuptiActivity) {
                    cuptiActivities.push([key, item]);
                } else {
                    ncclEvents.push([key, item]);
                }
            });
            
            // Group NCCL events by communicator, rank and type
            const groups = new Map();
            ncclEvents.forEach(([key, event]) => {
                const eventType = event.type || 'Unknown';
                const commid = event.commid || 'unknown';
                const groupKey = `comm${commid}_rank${event.rank}_type${eventType}`;
                if (!groups.has(groupKey)) {
                    groups.set(groupKey, []);
                }
                groups.get(groupKey).push([key, event]);
            });
            
            // Group CUPTI activities by GPU UUID (when available) or device ID and type
            const cuptiGroups = new Map();
            cuptiActivities.forEach(([key, activity]) => {
                const activityType = activity.type || 'CuptiOther';
                const gpuUuid = activity.gpuUuid || null;
                const deviceId = activity.deviceId !== null ? activity.deviceId : 'unknown';
                const groupKey = gpuUuid
                    ? `cupti_uuid${gpuUuid}_type${activityType}`
                    : `cupti_device${deviceId}_type${activityType}`;
                if (!cuptiGroups.has(groupKey)) {
                    cuptiGroups.set(groupKey, []);
                }
                cuptiGroups.get(groupKey).push([key, activity]);
            });
            
            // Track which lanes belong to which comm+rank+type combination
            // Map: groupKey -> array of lane indices for that group
            const groupLanes = new Map();
            
            // Track which lanes belong to which CUPTI device+type combination
            const cuptiGroupLanes = new Map();
            
            // Process each group separately
            Array.from(groups.entries()).sort((a, b) => {
                // Sort by communicator first, then rank, then by preferred type order
                const commidA = a[1][0][1].commid || 'unknown';
                const commidB = b[1][0][1].commid || 'unknown';
                if (commidA !== commidB) {
                    // Sort communicators by their index in eventsData.commids if available
                    if (eventsData.commids) {
                        const idxA = eventsData.commids.indexOf(commidA);
                        const idxB = eventsData.commids.indexOf(commidB);
                        if (idxA !== -1 && idxB !== -1) {
                            if (idxA !== idxB) return idxA - idxB;
                        } else if (idxA !== -1) return -1;
                        else if (idxB !== -1) return 1;
                    }
                    return commidA.localeCompare(commidB);
                }
                
                const rankA = a[1][0][1].rank;
                const rankB = b[1][0][1].rank;
                if (rankA !== rankB) return rankA - rankB;
                
                const typeA = a[1][0][1].type || 'Unknown';
                const typeB = b[1][0][1].type || 'Unknown';
                const priorityA = getEventTypePriority(typeA);
                const priorityB = getEventTypePriority(typeB);
                
                // If priorities are equal, sort alphabetically
                if (priorityA !== priorityB) return priorityA - priorityB;
                return typeA.localeCompare(typeB);
            }).forEach(([groupKey, groupEvents]) => {
                // Initialize lane tracking for this group
                if (!groupLanes.has(groupKey)) {
                    groupLanes.set(groupKey, []);
                }
                const groupLaneIndices = groupLanes.get(groupKey);
                
                // Sort events in this group by start time
                const sortedEvents = groupEvents.sort((a, b) => {
                    const boundsA = getEventBounds(a[1]);
                    const boundsB = getEventBounds(b[1]);
                    return boundsA.start - boundsB.start;
                });
                
                // Assign lanes within this group
                sortedEvents.forEach(([key, event]) => {
                    const eventBounds = getEventBounds(event);
                    
                    let assignedLane = -1;
                    
                    if (groupByType) {
                        // Mode: Allow multiple non-overlapping events of same type on same lane
                        // Try to find an existing lane of this comm+rank+type that doesn't have overlapping events
                        // Prefer the first lane (lowest index) of this type
                        
                        // Check existing lanes for this group (sorted by index, so first match is the "first" lane)
                        for (const laneIndex of groupLaneIndices) {
                            const laneEvents = lanes[laneIndex];
                            
                            // Check if this event overlaps with any event in this lane
                            const hasOverlap = laneEvents.some(([otherKey, otherEvent]) => {
                                return eventsOverlap(event, otherEvent);
                            });
                            
                            if (!hasOverlap) {
                                // Found a non-overlapping lane - use it (this is the first available)
                                assignedLane = laneIndex;
                                break;
                            }
                        }
                    } else {
                        // Mode: One event per lane (no "stuffing" - creates nice reading direction)
                        // Always create a new lane for each event
                    }
                    
                    // If no existing lane works (or if groupByType is false), create a new one
                    if (assignedLane === -1) {
                        assignedLane = lanes.length;
                        lanes.push([]);
                        groupLaneIndices.push(assignedLane);
                    }
                    
                    lanes[assignedLane].push([key, event]);
                    eventToLane.set(key, assignedLane);
                });
            });
            
            // Process CUPTI activity groups into lanes (similar to NCCL events)
            Array.from(cuptiGroups.entries()).sort((a, b) => {
                // Sort by GPU UUID first (when available), then device ID, then activity type
                const uuidA = a[1][0][1].gpuUuid || '';
                const uuidB = b[1][0][1].gpuUuid || '';
                if (uuidA !== uuidB) return uuidA.localeCompare(uuidB);
                
                const deviceIdA = a[1][0][1].deviceId !== null ? a[1][0][1].deviceId : -1;
                const deviceIdB = b[1][0][1].deviceId !== null ? b[1][0][1].deviceId : -1;
                if (deviceIdA !== deviceIdB) return deviceIdA - deviceIdB;
                
                const typeA = a[1][0][1].type || 'CuptiOther';
                const typeB = b[1][0][1].type || 'CuptiOther';
                return typeA.localeCompare(typeB);
            }).forEach(([groupKey, groupActivities]) => {
                // Initialize lane tracking for this CUPTI group
                if (!cuptiGroupLanes.has(groupKey)) {
                    cuptiGroupLanes.set(groupKey, []);
                }
                const groupLaneIndices = cuptiGroupLanes.get(groupKey);
                
                // Sort activities in this group by start time
                const sortedActivities = groupActivities.sort((a, b) => {
                    const boundsA = getEventBounds(a[1]);
                    const boundsB = getEventBounds(b[1]);
                    return boundsA.start - boundsB.start;
                });
                
                // Assign lanes within this group
                sortedActivities.forEach(([key, activity]) => {
                    const activityBounds = getEventBounds(activity);
                    
                    let assignedLane = -1;
                    
                    if (groupByType) {
                        // Mode: Allow multiple non-overlapping activities of same type on same lane
                        for (const laneIndex of groupLaneIndices) {
                            const laneEvents = lanes[laneIndex];
                            
                            // Check if this activity overlaps with any event in this lane
                            const hasOverlap = laneEvents.some(([otherKey, otherEvent]) => {
                                return eventsOverlap(activity, otherEvent);
                            });
                            
                            if (!hasOverlap) {
                                assignedLane = laneIndex;
                                break;
                            }
                        }
                    }
                    
                    // If no existing lane works, create a new one
                    if (assignedLane === -1) {
                        assignedLane = lanes.length;
                        lanes.push([]);
                        groupLaneIndices.push(assignedLane);
                    }
                    
                    lanes[assignedLane].push([key, activity]);
                    activityToLane.set(key, assignedLane);
                });
            });
            
            return { lanes, eventToLane, activityToLane };
        }
        
        function organizeLanesByCommContext() {
            // Group events by communicator, context and rank first, then assign lanes within each group
            // This is the old/original lane organization mode
            const lanes = [];
            const eventToLane = new Map();
            
            // Group events by commid, context and rank
            const groups = new Map();
            filteredEvents.forEach(([key, event]) => {
                // Include commid in grouping to separate events from different communicators
                const groupKey = `comm${event.commid || 'unknown'}_${event.ctx}_rank${event.rank}`;
                if (!groups.has(groupKey)) {
                    groups.set(groupKey, []);
                }
                groups.get(groupKey).push([key, event]);
            });
            
            // Process each group separately to keep them visually together
            Array.from(groups.entries()).sort((a, b) => {
                // Sort by rank first, then context
                const rankA = a[1][0][1].rank;
                const rankB = b[1][0][1].rank;
                if (rankA !== rankB) return rankA - rankB;
                return a[0].localeCompare(b[0]);
            }).forEach(([groupKey, groupEvents]) => {
                // Sort events in this group by start time
                const sortedEvents = groupEvents.sort((a, b) => {
                    const boundsA = getEventBounds(a[1]);
                    const boundsB = getEventBounds(b[1]);
                    return boundsA.start - boundsB.start;
                });
                
                // Assign lanes within this group (simple algorithm: assign to first available lane)
                sortedEvents.forEach(([key, event]) => {
                    const eventBounds = getEventBounds(event);
                    
                    // Find first lane in current group that doesn't overlap
                    let assignedLane = -1;
                    
                    for (let i = 0; i < lanes.length; i++) {
                        const laneEvents = lanes[i];
                        // Check if this lane belongs to the same group
                        if (laneEvents.length > 0) {
                            const firstEvent = laneEvents[0][1];
                            const laneGroupKey = `comm${firstEvent.commid || 'unknown'}_${firstEvent.ctx}_rank${firstEvent.rank}`;
                            if (laneGroupKey !== groupKey) continue;
                        }
                        
                        const overlaps = laneEvents.some(([otherKey, otherEvent]) => {
                            return eventsOverlap(event, otherEvent);
                        });
                        if (!overlaps) {
                            assignedLane = i;
                            break;
                        }
                    }
                    
                    if (assignedLane === -1) {
                        assignedLane = lanes.length;
                        lanes.push([]);
                    }
                    
                    lanes[assignedLane].push([key, event]);
                    eventToLane.set(key, assignedLane);
                });
            });
            
            return { lanes, eventToLane };
        }
        
        function organizeLanes() {
            // Always use comm+rank+type grouping with preferred type order
            // The toggle controls whether we allow multiple non-overlapping events per lane
            // (groupByType=true) or force one event per lane (groupByType=false)
            const result = organizeLanesByType();
            // Ensure activityToLane exists
            if (!result.activityToLane) {
                result.activityToLane = new Map();
            }
            return result;
        }
        
        function timeToX(time) {
            // Map time to content area only (labels occupy [0, LABEL_WIDTH])
            if (!timelineContentWidth || timelineContentWidth <= 0) timelineContentWidth = 1;
            return LABEL_WIDTH + ((time - minTime) / (maxTime - minTime)) * timelineContentWidth + panX;
        }
        
        function xToTime(x) {
            // Convert X position back to time (content area only)
            if (!timelineContentWidth || timelineContentWidth <= 0) timelineContentWidth = 1;
            return minTime + ((x - LABEL_WIDTH - panX) / timelineContentWidth) * (maxTime - minTime);
        }
        
        function drawParentChildArrows(lanes, eventToLane, renderedEventsMap) {
            if (!eventsData.parent_child_map || !eventsData.events) return;
            
            ctx.globalAlpha = 0.6; // Semi-transparent so arrows don't obscure events
            ctx.strokeStyle = '#1565c0';
            ctx.lineWidth = 1.5;
            ctx.setLineDash([4, 4]); // Dashed line for arrows
            
            // Draw arrows for each parent-child relationship
            Object.entries(eventsData.parent_child_map).forEach(([parentId, childIds]) => {
                // Look up from rendered events map (filtered events with bounds)
                const parentEvent = renderedEventsMap.get(parentId);
                if (!parentEvent || !parentEvent._bounds) return;
                
                childIds.forEach(childId => {
                    const childEvent = renderedEventsMap.get(childId);
                    if (!childEvent || !childEvent._bounds) return;
                    
                    // Get parent and child positions
                    const parentLane = eventToLane.get(parentId);
                    const childLane = eventToLane.get(childId);
                    
                    if (parentLane === undefined || childLane === undefined) return;
                    
                    const parentY = 40 + parentLane * laneHeight + laneHeight / 2;
                    const childY = 40 + childLane * laneHeight + laneHeight / 2;
                    
                    // Use the center of the event bar for connection points
                    const parentX = parentEvent._bounds.startX !== undefined && parentEvent._bounds.endX !== undefined
                        ? (parentEvent._bounds.startX + parentEvent._bounds.endX) / 2
                        : (parentEvent._bounds.startX || parentEvent._bounds.endX || 0);
                    
                    const childX = childEvent._bounds.startX !== undefined && childEvent._bounds.endX !== undefined
                        ? (childEvent._bounds.startX + childEvent._bounds.endX) / 2
                        : (childEvent._bounds.startX || childEvent._bounds.endX || 0);
                    
                    // Draw curved arrow using Bezier curve
                    // Control points for smooth curve
                    const midX = (parentX + childX) / 2;
                    const controlY1 = parentY + (childY > parentY ? 20 : -20);
                    const controlY2 = childY + (childY > parentY ? -20 : 20);
                    
                    ctx.beginPath();
                    ctx.moveTo(parentX, parentY);
                    // Use Bezier curve for smooth connection
                    ctx.bezierCurveTo(
                        midX, controlY1,
                        midX, controlY2,
                        childX, childY
                    );
                    ctx.stroke();
                    
                    // Draw arrowhead at child end
                    const angle = Math.atan2(childY - controlY2, childX - midX);
                    const arrowLength = 8;
                    const arrowWidth = 4;
                    
                    ctx.beginPath();
                    ctx.moveTo(childX, childY);
                    ctx.lineTo(
                        childX - arrowLength * Math.cos(angle - Math.PI / 6),
                        childY - arrowLength * Math.sin(angle - Math.PI / 6)
                    );
                    ctx.moveTo(childX, childY);
                    ctx.lineTo(
                        childX - arrowLength * Math.cos(angle + Math.PI / 6),
                        childY - arrowLength * Math.sin(angle + Math.PI / 6)
                    );
                    ctx.stroke();
                });
            });
            
            ctx.setLineDash([]); // Reset line dash
            ctx.globalAlpha = 1.0; // Reset opacity
        }
        
        function drawCollectiveConnections(renderedEventsMap, eventToLane) {
            const collectives = new Map();
            
            // Group rendered events by collective identifier
            for (const [key, event] of renderedEventsMap.entries()) {
                // Only consider events that have a sequence number and belong to a communicator
                // Usually these are CollApi, Coll, etc.
                if (event.seq_number !== undefined && event.seq_number !== null && event.commid) {
                    // Group by commid, seq_number, function name (e.g. AllReduce), and event type
                    // This ensures we connect the same collective operation across ranks
                    // Use empty string for null/undefined func to ensure consistent grouping
                    const funcName = event.func || '';
                    const groupKey = `${event.commid}_${event.seq_number}_${funcName}_${event.type}`;
                    if (!collectives.has(groupKey)) {
                        collectives.set(groupKey, []);
                    }
                    collectives.get(groupKey).push({key, event});
                }
            }
            
            ctx.save();
            ctx.globalAlpha = 0.6;
            ctx.strokeStyle = '#b91c1c'; // Red for connections
            ctx.lineWidth = 1.5;
            // No dash for collective connections to distinguish from parent-child arrows
            
            for (const [groupKey, groupEvents] of collectives.entries()) {
                if (groupEvents.length < 2) continue;
                
                // Sort by lane index to draw top-to-bottom lines across ranks
                groupEvents.sort((a, b) => {
                    const laneA = eventToLane.get(a.key);
                    const laneB = eventToLane.get(b.key);
                    return laneA - laneB;
                });
                
                ctx.beginPath();
                for (let i = 0; i < groupEvents.length; i++) {
                    const {key, event} = groupEvents[i];
                    const lane = eventToLane.get(key);
                    if (lane === undefined) continue;
                    
                    const y = 40 + lane * laneHeight + laneHeight / 2;
                    
                    // Use center of the event bar for connection points
                    const x = event._bounds.startX !== undefined && event._bounds.endX !== undefined
                        ? (event._bounds.startX + event._bounds.endX) / 2
                        : (event._bounds.startX || event._bounds.endX || 0);
                        
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        // Draw line to this event
                        ctx.lineTo(x, y);
                    }
                }
                ctx.stroke();
            }
            ctx.restore();
        }
        
        function drawProfilerLifecycleConnections(renderedEventsMap, eventToLane) {
            const lifecyclePairs = new Map();
            
            // Group rendered ProfilerLifecycle events by commId and rank
            for (const [key, event] of renderedEventsMap.entries()) {
                // Only consider ProfilerLifecycle events
                if (event.type === 'ProfilerLifecycle' && event.func && event.commid !== undefined && event.rank !== undefined) {
                    // Create a key based on commId and rank to pair init and finalize
                    const pairKey = `${event.commid}_${event.rank}`;
                    
                    if (!lifecyclePairs.has(pairKey)) {
                        lifecyclePairs.set(pairKey, { init: null, finalize: null });
                    }
                    
                    const pair = lifecyclePairs.get(pairKey);
                    if (event.func === 'ProfilerInit' || event.func === 'profilerInit') {
                        pair.init = { key, event };
                    } else if (event.func === 'ProfilerFinalize' || event.func === 'profilerFinalize' || event.func === 'finalize') {
                        pair.finalize = { key, event };
                    }
                }
            }
            
            ctx.save();
            ctx.globalAlpha = 0.6;
            ctx.strokeStyle = '#616161'; // Grey for profiler lifecycle connections
            ctx.lineWidth = 1.5;
            ctx.setLineDash([3, 3]); // Dashed line to distinguish from collective connections
            
            for (const [pairKey, pair] of lifecyclePairs.entries()) {
                // Only draw if we have both init and finalize
                if (pair.init && pair.finalize) {
                    const initLane = eventToLane.get(pair.init.key);
                    const finalizeLane = eventToLane.get(pair.finalize.key);
                    
                    if (initLane === undefined || finalizeLane === undefined) continue;
                    
                    const initY = 40 + initLane * laneHeight + laneHeight / 2;
                    const finalizeY = 40 + finalizeLane * laneHeight + laneHeight / 2;
                    
                    // Use center of the event bar for connection points
                    const initX = pair.init.event._bounds.startX !== undefined && pair.init.event._bounds.endX !== undefined
                        ? (pair.init.event._bounds.startX + pair.init.event._bounds.endX) / 2
                        : (pair.init.event._bounds.startX || pair.init.event._bounds.endX || 0);
                    
                    const finalizeX = pair.finalize.event._bounds.startX !== undefined && pair.finalize.event._bounds.endX !== undefined
                        ? (pair.finalize.event._bounds.startX + pair.finalize.event._bounds.endX) / 2
                        : (pair.finalize.event._bounds.startX || pair.finalize.event._bounds.endX || 0);
                    
                    // Draw line connecting init to finalize
                    ctx.beginPath();
                    ctx.moveTo(initX, initY);
                    ctx.lineTo(finalizeX, finalizeY);
                    ctx.stroke();
                }
            }
            
            ctx.setLineDash([]); // Reset line dash
            ctx.restore();
        }
        
        function drawCorrelationConnections(renderedEventsMap, renderedActivitiesMap, eventToLane, activityToLane) {
            if (!eventsData.extCorrIdToNcclEvents || !eventsData.extCorrIdToCuptiActivities) return;
            
            ctx.save();
            ctx.globalAlpha = 0.7;
            ctx.strokeStyle = '#059669'; // Green for correlation connections
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 3]); // Dotted line to distinguish from other connections
            
            // Iterate through all correlation keys (extCorrId_pid or extCorrId)
            const allCorrelationKeys = new Set([
                ...Array.from(eventsData.extCorrIdToNcclEvents.keys()),
                ...Array.from(eventsData.extCorrIdToCuptiActivities.keys())
            ]);
            
            for (const correlationKey of allCorrelationKeys) {
                const ncclEventKeys = eventsData.extCorrIdToNcclEvents.get(correlationKey) || [];
                const cuptiActivityKeys = eventsData.extCorrIdToCuptiActivities.get(correlationKey) || [];
                
                // Draw connections from each NCCL event to each correlated CUPTI activity
                ncclEventKeys.forEach(ncclKey => {
                    const ncclEvent = renderedEventsMap.get(ncclKey);
                    if (!ncclEvent || !ncclEvent._bounds) return;
                    
                    const ncclLane = eventToLane.get(ncclKey);
                    if (ncclLane === undefined) return;
                    
                    const ncclY = 40 + ncclLane * laneHeight + laneHeight / 2;
                    const ncclX = ncclEvent._bounds.startX !== undefined && ncclEvent._bounds.endX !== undefined
                        ? (ncclEvent._bounds.startX + ncclEvent._bounds.endX) / 2
                        : (ncclEvent._bounds.startX || ncclEvent._bounds.endX || 0);
                    
                    cuptiActivityKeys.forEach(cuptiKey => {
                        const cuptiActivity = renderedActivitiesMap.get(cuptiKey);
                        if (!cuptiActivity || !cuptiActivity._bounds) return;
                        
                        const cuptiLane = activityToLane.get(cuptiKey);
                        if (cuptiLane === undefined) return;
                        
                        const cuptiY = 40 + cuptiLane * laneHeight + laneHeight / 2;
                        const cuptiX = cuptiActivity._bounds.startX !== undefined && cuptiActivity._bounds.endX !== undefined
                            ? (cuptiActivity._bounds.startX + cuptiActivity._bounds.endX) / 2
                            : (cuptiActivity._bounds.startX || cuptiActivity._bounds.endX || 0);
                        
                        // Draw Bezier curve from NCCL event to CUPTI activity
                        const midX = (ncclX + cuptiX) / 2;
                        const controlY1 = ncclY + (cuptiY > ncclY ? 30 : -30);
                        const controlY2 = cuptiY + (cuptiY > ncclY ? -30 : 30);
                        
                        ctx.beginPath();
                        ctx.moveTo(ncclX, ncclY);
                        ctx.bezierCurveTo(midX, controlY1, midX, controlY2, cuptiX, cuptiY);
                        ctx.stroke();
                        
                        // Draw arrowhead at CUPTI activity end
                        const angle = Math.atan2(cuptiY - controlY2, cuptiX - midX);
                        const arrowLength = 10;
                        const arrowWidth = 5;
                        
                        ctx.beginPath();
                        ctx.moveTo(cuptiX, cuptiY);
                        ctx.lineTo(
                            cuptiX - arrowLength * Math.cos(angle - Math.PI / 6),
                            cuptiY - arrowLength * Math.sin(angle - Math.PI / 6)
                        );
                        ctx.moveTo(cuptiX, cuptiY);
                        ctx.lineTo(
                            cuptiX - arrowLength * Math.cos(angle + Math.PI / 6),
                            cuptiY - arrowLength * Math.sin(angle + Math.PI / 6)
                        );
                        ctx.stroke();
                    });
                });
            }
            
            ctx.setLineDash([]); // Reset line dash
            ctx.restore();
        }
        
        /**
         * Draw visualization elements for an event.
         * 
         * Visualization Elements Used:
         * 1. RECTANGULAR BARS: For events with both start and stop timestamps
         *    - Full-width colored rectangle spanning from start to stop time
         *    - Shows function name label if space allows
         * 
         * 2. RIGHT-POINTING TRIANGLES: For events with only start timestamp
         *    - Triangle pointing right, indicating event started but hasn't stopped
         *    - Positioned at the start timestamp
         * 
         * 3. LEFT-POINTING TRIANGLES: For events with only stop timestamp
         *    - Triangle pointing left, indicating event stopped but start is missing
         *    - Positioned at the stop timestamp
         * 
         * 4. CIRCLES/DOTS: For events with no start or stop timestamps
         *    - Small circle positioned at first state timestamp (or default position)
         *    - Used for events that only have state transitions
         * 
         * 5. STATE MARKERS (two types):
         *    a) SPEECH BUBBLES: For standalone states or states outside event bounds
         *       - Red circular bubble with a small pointer triangle below
         *       - Indicates state transition that's not part of a complete event
         *    b) SMALL CIRCLES: For states within event bounds
         *       - Small red dot positioned above the event bar
         *       - Marks state transitions that occur during an event's lifetime
         */
        function drawBar(event, lane, y, isHovered = false, isHighlighted = false, highlightedStateIdx = null) {
            const height = laneHeight * 0.8;
            const centerY = y + laneHeight / 2;
            const color = EVENT_COLORS[event.type] || EVENT_COLORS['Unknown'];
            
            // Determine stroke style based on hover/highlight state
            let strokeStyle = '#333';
            let lineWidth = 1;
            if (isHighlighted) {
                strokeStyle = '#1565c0'; // Blue for highlighted
                lineWidth = 3;
            } else if (isHovered) {
                strokeStyle = '#ca8a04'; // Amber for hovered
                lineWidth = 2;
            }
            
            let startX, endX;
            
            if (event.start !== null && event.stop !== null) {
                // 1. FULL BAR - both start and end exist (clamp left to label column so label stays readable)
                startX = Math.max(LABEL_WIDTH, timeToX(event.start));
                // ProfilerLifecycle events are 0Âµs in the trace; draw them as 1Âµs so the bar is visible but proportional
                const stopTime = (event.type === 'ProfilerLifecycle' && event.start === event.stop)
                    ? event.start + 1
                    : event.stop;
                endX = timeToX(stopTime);
                const width = Math.max(0, endX - startX);
                
                ctx.fillStyle = color;
                if (width > 0) ctx.fillRect(startX, centerY - height/2, width, height);
                ctx.strokeStyle = strokeStyle;
                ctx.lineWidth = lineWidth;
                if (width > 0) ctx.strokeRect(startX, centerY - height/2, width, height);
                
                // Draw label if space allows
                if (width > 50) {
                    ctx.fillStyle = '#1f2937';
                    ctx.font = '10px monospace';
                    let label = event.func || event.type;
                    // For CUPTI activities, show kernel name or activity type
                    if (event.isCuptiActivity) {
                        if (event.name) {
                            label = event.name;
                        } else if (event.type_name) {
                            label = event.type_name;
                        }
                        // For memcpy/memset, show size if available
                        if (event.size && (event.type === 'CuptiMemcpy' || event.type === 'CuptiMemset')) {
                            const sizeMB = (event.size / (1024 * 1024)).toFixed(2);
                            label += ` (${sizeMB}MB)`;
                        }
                    }
                    ctx.fillText(label, startX + 5, centerY + 3);
                }
            } else if (event.start !== null) {
                // 2. RIGHT-POINTING TRIANGLE (only start exists)
                startX = Math.max(LABEL_WIDTH, timeToX(event.start));
                endX = startX + height;
                
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.moveTo(startX, centerY - height/2);
                ctx.lineTo(startX + height, centerY);
                ctx.lineTo(startX, centerY + height/2);
                ctx.closePath();
                ctx.fill();
                ctx.strokeStyle = strokeStyle;
                ctx.lineWidth = lineWidth;
                ctx.stroke();
            } else if (event.stop !== null) {
                // 3. LEFT-POINTING TRIANGLE (only stop exists)
                endX = timeToX(event.stop);
                startX = Math.max(LABEL_WIDTH, endX - height);
                
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.moveTo(endX, centerY - height/2);
                ctx.lineTo(endX - height, centerY);
                ctx.lineTo(endX, centerY + height/2);
                ctx.closePath();
                ctx.fill();
                ctx.strokeStyle = strokeStyle;
                ctx.lineWidth = lineWidth;
                ctx.stroke();
            } else {
                // 4. CIRCLE/DOT (no start or stop - use first state timestamp or default)
                const hasStates = event.states && event.states.length > 0;
                const firstState = hasStates ? event.states[0].timestamp : minTime;
                startX = Math.max(LABEL_WIDTH, timeToX(firstState));
                endX = startX + height;
                
                // Draw as a small circle/dot
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(startX, centerY, 6, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = strokeStyle;
                ctx.lineWidth = lineWidth;
                ctx.stroke();
            }
            
            // 5. STATE MARKERS - Draw state transitions (CUPTI activities don't have states)
            const stateBounds = [];
            if (event.states) {
            event.states.forEach((state, stateIdx) => {
                const stateX = Math.max(LABEL_WIDTH, timeToX(state.timestamp));
                const isStateHighlighted = highlightedStateIdx === stateIdx;
                
                // Determine stroke style for highlighted state
                let stateStrokeStyle = '#333';
                let stateLineWidth = 1;
                if (isStateHighlighted) {
                    stateStrokeStyle = '#1565c0'; // Blue for highlighted
                    stateLineWidth = 3;
                }
                
                // Check if this state is within the actual drawn event bounds
                // For events with both start and stop, check against actual timestamps
                // For events with incomplete bounds, check if state is near the drawn element
                let isWithinEvent = false;
                if (event.start !== null && event.stop !== null) {
                    // Full bar: state must be between start and stop
                    isWithinEvent = state.timestamp >= event.start && state.timestamp <= event.stop;
                } else if (event.start !== null) {
                    // Right-pointing triangle: state should be near start (within a small window)
                    const window = (maxTime - minTime) * 0.01; // 1% of total time range
                    isWithinEvent = state.timestamp >= event.start && state.timestamp <= event.start + window;
                } else if (event.stop !== null) {
                    // Left-pointing triangle: state should be near stop (within a small window)
                    const window = (maxTime - minTime) * 0.01; // 1% of total time range
                    isWithinEvent = state.timestamp <= event.stop && state.timestamp >= event.stop - window;
                } else {
                    // Circle/dot: state should be near the first state (within a small window)
                    if (event.states.length > 0) {
                        const firstStateTime = event.states[0].timestamp;
                        const window = (maxTime - minTime) * 0.01; // 1% of total time range
                        isWithinEvent = Math.abs(state.timestamp - firstStateTime) <= window;
                    }
                }
                
                if (!isWithinEvent) {
                    // 5a. SPEECH BUBBLE - State outside event bounds
                    const bubbleSize = isStateHighlighted ? 10 : 8; // Slightly larger when highlighted
                    const bubbleY = centerY - bubbleSize;
                    
                    ctx.fillStyle = '#b91c1c';
                    ctx.beginPath();
                    // Bubble body
                    ctx.arc(stateX, bubbleY, bubbleSize, 0, Math.PI * 2);
                    ctx.fill();
                    // Bubble pointer
                    ctx.beginPath();
                    ctx.moveTo(stateX, bubbleY + bubbleSize);
                    ctx.lineTo(stateX - 3, centerY);
                    ctx.lineTo(stateX + 3, centerY);
                    ctx.closePath();
                    ctx.fill();
                    ctx.strokeStyle = stateStrokeStyle;
                    ctx.lineWidth = stateLineWidth;
                    ctx.stroke();
                    
                    // Store bounds for hover detection (bubble + pointer area)
                    stateBounds.push({
                        x: stateX - bubbleSize,
                        y: bubbleY - bubbleSize,
                        width: bubbleSize * 2,
                        height: centerY - (bubbleY - bubbleSize),
                        state: state,
                        stateIndex: stateIdx
                    });
                } else {
                    // 5b. SMALL CIRCLE - State within event bounds (marker on top of bar)
                    const markerY = centerY - height/2 - 5;
                    const markerRadius = isStateHighlighted ? 5 : 3; // Larger when highlighted
                    ctx.fillStyle = '#b91c1c';
                    ctx.beginPath();
                    ctx.arc(stateX, markerY, markerRadius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = stateStrokeStyle;
                    ctx.lineWidth = stateLineWidth;
                    ctx.stroke();
                    
                    // Store bounds for hover detection (small circle)
                    stateBounds.push({
                        x: stateX - markerRadius,
                        y: markerY - markerRadius,
                        width: markerRadius * 2,
                        height: markerRadius * 2,
                        state: state,
                        stateIndex: stateIdx
                    });
                }
            });
            } // end if (event.states)
            
            return { startX, endX, y: centerY - height/2, height, stateBounds };
        }
        
        function renderTimeline() {
            const container = document.getElementById('timeline-container');
            
            // Save scroll position before re-rendering
            const savedScrollLeft = container.scrollLeft;
            const savedScrollTop = container.scrollTop;
            
            if (!filteredEvents || filteredEvents.length === 0) {
                container.innerHTML = 
                    '<div class="loading">No events to display</div>';
                // Restore scroll position
                container.scrollLeft = savedScrollLeft;
                container.scrollTop = savedScrollTop;
                return;
            }
            
            container.innerHTML = '<canvas id="timeline-canvas"></canvas>';
            canvas = document.getElementById('timeline-canvas');
            ctx = canvas.getContext('2d');
            
            calculateTimeRange();
            const { lanes, eventToLane, activityToLane } = organizeLanes();
            if (!activityToLane) {
                // Fallback if organizeLanes doesn't return activityToLane
                activityToLane = new Map();
            }
            
            // Restore highlighted event from key (if it still exists in filtered events)
            highlightedEvent = null;
            if (highlightedEventKey) {
                // Check if the highlighted event still exists in filtered events
                const stillExists = filteredEvents.some(([key, event]) => key === highlightedEventKey);
                if (!stillExists) {
                    // Event was filtered out, clear the highlight
                    highlightedEventKey = null;
                }
            }
            
            // Restore highlighted state (if it still exists in filtered events)
            if (highlightedStateKey) {
                const stillExists = filteredEvents.some(([key, event]) => {
                    if (key === highlightedStateKey && event.states && event.states.length > highlightedStateIndex) {
                        return true;
                    }
                    return false;
                });
                if (!stillExists) {
                    // State was filtered out, clear the highlight
                    highlightedStateKey = null;
                    highlightedStateIndex = null;
                }
            }
            
            // Map to track rendered events (key -> event with bounds) for arrow drawing
            const renderedEventsMap = new Map();
            // Map to track rendered CUPTI activities (key -> activity with bounds) for correlation connections
            const renderedActivitiesMap = new Map();
            
            // Set canvas size - make it wider if zoomed in to enable horizontal scrolling
            const containerWidth = container.clientWidth - 40;
            // Canvas width scales with zoom: when zoomed in, canvas is wider for horizontal scrolling
            const canvasWidth = containerWidth * zoom;
            const containerHeight = Math.max(400, lanes.length * laneHeight + 100);
            canvas.width = canvasWidth;
            canvas.height = containerHeight;
            timelineContentWidth = Math.max(1, canvas.width - LABEL_WIDTH);
            
            // Clear canvas
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw time axis (content area only, so labels stay readable)
            ctx.strokeStyle = '#999';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(LABEL_WIDTH, 20);
            ctx.lineTo(canvas.width, 20);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(LABEL_WIDTH, 0);
            ctx.lineTo(LABEL_WIDTH, 20);
            ctx.stroke();
            
            // Draw time labels in content area only
            ctx.fillStyle = '#555555';
            ctx.font = '12px monospace';
            const numLabels = 10;
            for (let i = 0; i <= numLabels; i++) {
                const time = minTime + (maxTime - minTime) * (i / numLabels);
                const x = LABEL_WIDTH + (i / numLabels) * timelineContentWidth + panX;
                if (x >= LABEL_WIDTH && x <= canvas.width) {
                    ctx.fillText(`${time.toFixed(0)}Î¼s`, x, 15);
                    ctx.beginPath();
                    ctx.moveTo(x, 20);
                    ctx.lineTo(x, 25);
                    ctx.stroke();
                }
            }
            
            // Lane background colors for alternating by context (NCCL: comm+ctx; CUPTI: device+type)
            const LANE_BG_A = '#f0f0f0';
            const LANE_BG_B = '#e5e5e5';
            let prevContextKey = null;
            let useAltLaneBg = false;
            
            // First pass: Draw events and calculate bounds (needed for arrow drawing)
            lanes.forEach((laneEvents, laneIndex) => {
                const y = 40 + laneIndex * laneHeight;
                
                // Alternating lane background by context/group
                if (laneEvents.length > 0) {
                    const first = laneEvents[0][1];
                    const contextKey = first.isCuptiActivity
                        ? (first.gpuUuid ? `cupti_u${first.gpuUuid}_${first.type || 'Other'}` : `cupti_d${first.deviceId ?? '?'}_${first.type || 'Other'}`)
                        : `${first.commid || 'unknown'}_${first.ctx ?? ''}`;
                    if (contextKey !== prevContextKey) {
                        prevContextKey = contextKey;
                        useAltLaneBg = !useAltLaneBg;
                    }
                }
                ctx.fillStyle = useAltLaneBg ? LANE_BG_B : LANE_BG_A;
                ctx.fillRect(0, y, canvas.width, laneHeight);
                
                // Vertical separator between label column and timeline content
                ctx.strokeStyle = '#bbb';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(LABEL_WIDTH, y);
                ctx.lineTo(LABEL_WIDTH, y + laneHeight);
                ctx.stroke();
                
                // Draw lane separator
                ctx.beginPath();
                ctx.moveTo(0, y + laneHeight);
                ctx.lineTo(canvas.width, y + laneHeight);
                ctx.stroke();
                
                // Draw lane label
                if (laneEvents.length > 0) {
                    const firstEvent = laneEvents[0][1];
                    
                    // Check if all events in lane have the same thread ID
                    const tids = new Set();
                    laneEvents.forEach(([k, e]) => {
                        if (e.start_tid !== undefined && e.start_tid !== null) tids.add(e.start_tid);
                        if (e.stop_tid !== undefined && e.stop_tid !== null) tids.add(e.stop_tid);
                    });
                    
                    let label;
                    
                    // Check if this is a CUPTI activity lane
                    if (firstEvent.isCuptiActivity) {
                        // CUPTI activity lane label: prefer GPU UUID when available (short form for display)
                        const gpuLabel = firstEvent.gpuUuid
                            ? 'gpuUuid=' + (firstEvent.gpuUuid.length > 12 ? '...' + firstEvent.gpuUuid.slice(-8) : firstEvent.gpuUuid)
                            : `Device ${firstEvent.deviceId !== null && firstEvent.deviceId !== undefined ? firstEvent.deviceId : '?'}`;
                        label = `CUPTI | ${gpuLabel}`;
                        if (tids.size === 1) {
                            label += ` | tid=${Array.from(tids)[0]}`;
                        } else if (tids.size > 1) {
                            label += ` | tids: ${Array.from(tids).join(',')}`;
                        }
                        label += ` | ${laneEvents.length} activities`;
                    } else {
                        // NCCL event lane label
                        // Get communicator info (show first, as it's hierarchically above rank)
                        let commLabel = '';
                        if (firstEvent.commid && firstEvent.commid !== 'unknown') {
                            if (eventsData.commids && eventsData.commids.length > 0) {
                            const commIdx = eventsData.commids.indexOf(firstEvent.commid) + 1;
                                if (commIdx > 0) {
                            commLabel = `Comm#${commIdx}`;
                                } else {
                                    // CommId not in list, show short version
                                    const shortId = firstEvent.commid.length > 6 ? '...' + firstEvent.commid.slice(-6) : firstEvent.commid;
                                    commLabel = `Comm(${shortId})`;
                                }
                            } else {
                                // No commids list, show short version of this commid
                                const shortId = firstEvent.commid.length > 6 ? '...' + firstEvent.commid.slice(-6) : firstEvent.commid;
                                commLabel = `Comm(${shortId})`;
                            }
                        } else {
                            commLabel = 'Comm?';
                        }
                        
                        // Get context info (short version)
                        let ctxLabel = '';
                        if (firstEvent.ctx) {
                            const shortCtx = firstEvent.ctx.length > 8 ? '...' + firstEvent.ctx.slice(-6) : firstEvent.ctx;
                            ctxLabel = `ctx=${shortCtx}`;
                        }
                        
                        label = `${commLabel} | Rank ${firstEvent.rank}`;
                        if (ctxLabel) {
                            label += ` | ${ctxLabel}`;
                        }
                        if (tids.size === 1) {
                            // All events have the same thread ID
                            label += ` | tid=${Array.from(tids)[0]}`;
                        } else if (tids.size > 1) {
                            // Multiple thread IDs in this lane
                            label += ` | tids: ${Array.from(tids).join(',')}`;
                        }
                        label += ` | ${laneEvents.length} events`;
                    }
                    
                    // Draw lane label in reserved column (clip so it never spills into content area)
                    ctx.save();
                    ctx.beginPath();
                    ctx.rect(0, y, LABEL_WIDTH - 6, laneHeight);
                    ctx.clip();
                    ctx.fillStyle = '#555555';
                    ctx.font = '11px monospace';
                    ctx.fillText(label, 10, y + laneHeight / 2 + 4);
                    ctx.restore();
                }
                
                // Draw events in this lane and store bounds
                laneEvents.forEach(([key, event]) => {
                    // Store key on event for later reference
                    event._key = key;
                    
                    // Restore highlighted event if this is the one
                    if (highlightedEventKey === key) {
                        highlightedEvent = event;
                    }
                    
                    // Check if this event is hovered or highlighted
                    const isHovered = hoveredEvent === event;
                    const isHighlighted = highlightedEvent === event;
                    // Check if this event has a highlighted state
                    const stateHighlightIdx = (highlightedStateKey === key) ? highlightedStateIndex : null;
                    const bounds = drawBar(event, laneIndex, y, isHovered, isHighlighted, stateHighlightIdx);
                    
                    // Store bounds for hover detection and arrow drawing
                    event._bounds = bounds;
                    // Store state bounds for hover detection
                    // Note: stateBounds y coordinates are already in canvas coordinates
                    // (calculated from lane y + laneHeight/2 in drawBar)
                    if (bounds.stateBounds) {
                        event._stateBounds = bounds.stateBounds;
                    }
                    
                    // Add to appropriate rendered map for arrow/connection drawing
                    if (event.isCuptiActivity) {
                        renderedActivitiesMap.set(key, event);
                    } else {
                        renderedEventsMap.set(key, event);
                    }
                });
            });
            
            // Draw parent-child arrows after events are drawn (so arrows appear on top)
            // This makes it easier to see the relationships
            if (showParentArrows && eventsData.parent_child_map) {
                drawParentChildArrows(lanes, eventToLane, renderedEventsMap);
            }
            
            // Draw collective connections (connecting same seqNum across ranks)
            if (showCollectiveLines) {
                drawCollectiveConnections(renderedEventsMap, eventToLane);
            }
            
            // Draw profiler lifecycle connections (connecting init and finalize events)
            if (showProfilerLifecycleLines) {
                drawProfilerLifecycleConnections(renderedEventsMap, eventToLane);
            }
            
            // Draw correlation connections (connecting NCCL events to CUPTI activities via extCorrId)
            if (showCorrelationConnections && renderedActivitiesMap.size > 0) {
                drawCorrelationConnections(renderedEventsMap, renderedActivitiesMap, eventToLane, activityToLane);
            }
            
            // Draw selection rectangle if selecting (content area only)
            if (isSelecting) {
                const selStartX = Math.max(LABEL_WIDTH, Math.min(selectionStartX, selectionEndX));
                const selEndX = Math.min(canvas.width, Math.max(selectionStartX, selectionEndX));
                const selWidth = Math.max(0, selEndX - selStartX);
                
                if (selWidth > 0) {
                    ctx.fillStyle = 'rgba(21, 101, 192, 0.15)'; // Semi-transparent blue
                    ctx.fillRect(selStartX, 0, selWidth, canvas.height);
                    ctx.strokeStyle = '#1565c0';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    ctx.strokeRect(selStartX, 0, selWidth, canvas.height);
                    ctx.setLineDash([]);
                }
            }
            
            // Setup mouse interaction
            let mouseDownX = 0;
            let mouseDownY = 0;
            
            canvas.addEventListener('mousedown', (e) => {
                const rect = canvas.getBoundingClientRect();
                mouseDownX = e.clientX - rect.left;
                mouseDownY = e.clientY - rect.top;
                
                // Check if clicking on an event or state transition - if so, highlight it and don't start selection
                let clickedOnEvent = false;
                let clickedEvent = null;
                let clickedState = null;
                let clickedStateIndex = null;
                
                lanes.forEach((laneEvents) => {
                    laneEvents.forEach(([key, event]) => {
                        // Check for clicks on state transitions first (they're on top)
                        if (event._stateBounds) {
                            event._stateBounds.forEach(stateBound => {
                                const stateX = stateBound.x;
                                const stateY = stateBound.y;
                                const stateWidth = stateBound.width;
                                const stateHeight = stateBound.height;
                                
                                if (mouseDownX >= stateX && mouseDownX <= stateX + stateWidth &&
                                    mouseDownY >= stateY && mouseDownY <= stateY + stateHeight) {
                                    clickedOnEvent = true;
                                    clickedEvent = event;
                                    clickedState = stateBound.state;
                                    clickedStateIndex = stateBound.stateIndex;
                                }
                            });
                        }
                        
                        // Check for clicks on the main event bar (only if no state was clicked)
                        if (!clickedOnEvent && event._bounds && 
                            mouseDownX >= event._bounds.startX && mouseDownX <= event._bounds.endX &&
                            mouseDownY >= event._bounds.y && mouseDownY <= event._bounds.y + event._bounds.height) {
                            clickedOnEvent = true;
                            clickedEvent = event;
                        }
                    });
                });
                
                if (clickedOnEvent && clickedEvent) {
                    if (clickedState !== null && clickedStateIndex !== null) {
                        // Clicked on a state transition - highlight it
                        highlightedStateKey = clickedEvent._key;
                        highlightedStateIndex = clickedStateIndex;
                        highlightedEventKey = null; // Clear event highlight
                        highlightedEvent = null;
                    } else {
                        // Clicked on an event bar - highlight it
                        highlightedEventKey = clickedEvent._key;
                        highlightedStateKey = null; // Clear state highlight
                        highlightedStateIndex = null;
                    }
                    renderTimeline(); // Re-render to show highlight
                } else if (mouseDownY > 20) {
                    // Clicked on canvas (not on event) - clear highlights and start selection
                    highlightedEventKey = null;
                    highlightedEvent = null;
                    highlightedStateKey = null;
                    highlightedStateIndex = null;
                    isSelecting = true;
                    selectionStartX = Math.max(LABEL_WIDTH, mouseDownX);
                    selectionEndX = selectionStartX;
                    renderTimeline(); // Re-render to clear highlight
                }
            });
            
            canvas.addEventListener('mousemove', (e) => {
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                
                if (isSelecting) {
                    // Update selection end position (clamp to content area)
                    selectionEndX = Math.max(LABEL_WIDTH, Math.min(canvas.width, mouseX));
                    // Redraw to show updated selection
                    renderTimeline();
                    return;
                }
                
                // Find hovered event or state
                hoveredEvent = null;
                let hoveredState = null;
                
                // Helper function to check if expanded hover area would overlap with other events on the same lane
                function canExpandHoverArea(event, laneEvents, expandPx = HOVER_EXPAND) {
                    if (!event._bounds) return false;
                    
                    const expandedStartX = event._bounds.startX - expandPx;
                    const expandedEndX = event._bounds.endX + expandPx;
                    
                    // Check if expanded area would overlap with any other event on the same lane
                    for (const [otherKey, otherEvent] of laneEvents) {
                        if (otherEvent === event || !otherEvent._bounds) continue;
                        
                        // Check if expanded area overlaps with this other event
                        if (!(expandedEndX < otherEvent._bounds.startX || expandedStartX > otherEvent._bounds.endX)) {
                            return false; // Overlap detected, can't expand
                        }
                    }
                    
                    return true; // No overlap, can expand
                }
                
                lanes.forEach((laneEvents, laneIndex) => {
                    laneEvents.forEach(([key, event]) => {
                        // Check if mouse is over the main event bar (with expanded hover area if safe)
                        if (event._bounds) {
                            const canExpand = canExpandHoverArea(event, laneEvents, HOVER_EXPAND);
                            const hoverStartX = canExpand ? event._bounds.startX - HOVER_EXPAND : event._bounds.startX;
                            const hoverEndX = canExpand ? event._bounds.endX + HOVER_EXPAND : event._bounds.endX;
                            
                            if (mouseX >= hoverStartX && mouseX <= hoverEndX &&
                                mouseY >= event._bounds.y && mouseY <= event._bounds.y + event._bounds.height) {
                                hoveredEvent = event;
                            }
                        }
                        
                        // Check if mouse is over any state marker (speech bubble or small circle)
                        if (event._stateBounds) {
                            event._stateBounds.forEach(stateBound => {
                                // stateBound.y is already in canvas coordinates (relative to canvas top)
                                // because drawBar receives y (lane top) and calculates centerY from it
                                const stateX = stateBound.x;
                                const stateY = stateBound.y;
                                const stateWidth = stateBound.width;
                                const stateHeight = stateBound.height;
                                
                                if (mouseX >= stateX && mouseX <= stateX + stateWidth &&
                                    mouseY >= stateY && mouseY <= stateY + stateHeight) {
                                    hoveredEvent = event;
                                    hoveredState = stateBound.state;
                                }
                            });
                        }
                    });
                });
                
                if (hoveredEvent) {
                    canvas.style.cursor = 'pointer';
                    updateInfo(hoveredEvent, hoveredState);
                } else if (highlightedStateKey && highlightedStateIndex !== null) {
                    // Show info for highlighted state
                    const highlightedStateEvent = filteredEvents.find(([key, event]) => key === highlightedStateKey)?.[1];
                    if (highlightedStateEvent && highlightedStateEvent.states && highlightedStateEvent.states[highlightedStateIndex]) {
                        canvas.style.cursor = 'default';
                        updateInfo(highlightedStateEvent, highlightedStateEvent.states[highlightedStateIndex]);
                    }
                } else if (highlightedEvent) {
                    // Keep showing info for highlighted event even when not hovering
                    canvas.style.cursor = 'default';
                    updateInfo(highlightedEvent, null);
                } else {
                    canvas.style.cursor = isSelecting ? 'crosshair' : 'default';
                    if (!isSelecting) {
                        document.getElementById('info-text').textContent = 'Hover over events to see details';
                    }
                }
            });
            
            canvas.addEventListener('mouseup', (e) => {
                if (isSelecting) {
                    const rect = canvas.getBoundingClientRect();
                    const mouseX = e.clientX - rect.left;
                    selectionEndX = Math.max(LABEL_WIDTH, Math.min(canvas.width, mouseX));
                    
                    // Calculate time range from selection (use content-area coordinates)
                    const selStartX = Math.max(LABEL_WIDTH, Math.min(selectionStartX, selectionEndX));
                    const selEndX = Math.min(canvas.width, Math.max(selectionStartX, selectionEndX));
                    
                    // Only apply if selection is meaningful (at least 10 pixels wide)
                    if (selEndX - selStartX > 10) {
                        const selectedMinTime = xToTime(selStartX);
                        const selectedMaxTime = xToTime(selEndX);
                        
                        // xToTime returns normalized time if normalizeTime is true
                        // So we can directly use it for the inputs
                        document.getElementById('time-min').value = Math.round(selectedMinTime);
                        document.getElementById('time-max').value = Math.round(selectedMaxTime);
                        
                        // Apply filters
                        applyFilters();
                    }
                    
                    // Reset selection
                    isSelecting = false;
                    selectionStartX = 0;
                    selectionEndX = 0;
                    renderTimeline();
                }
            });
            
            // Cancel selection if mouse leaves canvas
            canvas.addEventListener('mouseleave', () => {
                if (isSelecting) {
                    isSelecting = false;
                    selectionStartX = 0;
                    selectionEndX = 0;
                    renderTimeline();
                }
            });
            
            // Show highlighted state or event info if it exists and no event is being hovered
            if (hoveredEvent) {
                // Hovered event takes priority
            } else if (highlightedStateKey && highlightedStateIndex !== null) {
                // Show info for highlighted state
                const highlightedStateEvent = filteredEvents.find(([key, event]) => key === highlightedStateKey)?.[1];
                if (highlightedStateEvent && highlightedStateEvent.states && highlightedStateEvent.states[highlightedStateIndex]) {
                    updateInfo(highlightedStateEvent, highlightedStateEvent.states[highlightedStateIndex]);
                }
            } else if (highlightedEvent) {
                updateInfo(highlightedEvent, null);
            } else {
                document.getElementById('info-text').textContent = 'Hover over events to see details';
            }
            
            // Prevent clicks on infobox from clearing highlight
            const infoPanel = document.querySelector('.info-panel');
            if (infoPanel) {
                infoPanel.addEventListener('mousedown', (e) => {
                    e.stopPropagation(); // Prevent event from bubbling to document
                });
                infoPanel.addEventListener('click', (e) => {
                    e.stopPropagation(); // Prevent event from bubbling to document
                });
            }
            
            // Restore scroll position after rendering (use requestAnimationFrame to ensure DOM is updated)
            requestAnimationFrame(() => {
                container.scrollLeft = savedScrollLeft;
                container.scrollTop = savedScrollTop;
            });
        }
        
        function updateInfo(event, hoveredState = null) {
            const lines = [];
            
            // If hovering over a specific state, show that state's info prominently
            if (hoveredState) {
                lines.push('<strong style="color: #b91c1c;">State Transition (Hovered)</strong>');
                lines.push(`State Name: ${hoveredState.state_name || 'Unknown'}`);
                lines.push(`State ID: ${hoveredState.state_id || 'N/A'}`);
                if (hoveredState.tid !== undefined && hoveredState.tid !== null) {
                    lines.push(`Thread ID: ${hoveredState.tid}`);
                }
                if (hoveredState.pid !== undefined && hoveredState.pid !== null) {
                    lines.push(`Process ID: ${hoveredState.pid}`);
                }
                lines.push(`Timestamp: ${hoveredState.timestamp.toFixed(3)}Î¼s`);
                
                if (hoveredState.details && Object.keys(hoveredState.details).length > 0) {
                    lines.push('');
                    lines.push('State Details:');
                    for (const [key, value] of Object.entries(hoveredState.details)) {
                        if (typeof value === 'object') {
                            lines.push(`  ${key}: ${JSON.stringify(value)}`);
                        } else {
                            lines.push(`  ${key}: ${value}`);
                        }
                    }
                }
                
                lines.push('');
                lines.push('<strong>Parent Event:</strong>');
            }
            
            // Check if this is a CUPTI activity
            if (event.isCuptiActivity) {
                // CUPTI Activity Information
                lines.push(`<strong style="color: #059669;">CUPTI Activity</strong>`);
                lines.push(`Activity Type: ${event.type_name || event.type || 'Unknown'}`);
                
                if (event.name) {
                    lines.push(`Kernel/Function Name: ${event.name}`);
                }
                
                if (event.deviceId !== null && event.deviceId !== undefined) {
                    lines.push(`Device ID: ${event.deviceId}`);
                }
                
                if (event.stream) {
                    lines.push(`Stream: ${event.stream}`);
                }
                
                if (event.size) {
                    const sizeMB = (event.size / (1024 * 1024)).toFixed(2);
                    lines.push(`Size: ${event.size} bytes (${sizeMB} MB)`);
                }
                
                if (event.gpuUuid) {
                    lines.push(`GPU UUID: ${event.gpuUuid}`);
                }
                
                // Process and thread IDs
                if (event.start_pid !== undefined && event.start_pid !== null) {
                    if (event.stop_pid !== undefined && event.stop_pid !== null && event.start_pid !== event.stop_pid) {
                        lines.push(`<strong style="color: #dc2626;">Start Process ID: ${event.start_pid}</strong>`);
                        lines.push(`<strong style="color: #dc2626;">Stop Process ID: ${event.stop_pid}</strong> (different process!)`);
                    } else {
                        lines.push(`Process ID: ${event.start_pid}`);
                    }
                }
                
                if (event.start_tid !== undefined && event.start_tid !== null) {
                    if (event.stop_tid !== undefined && event.stop_tid !== null && event.start_tid !== event.stop_tid) {
                        lines.push(`<strong style="color: #dc2626;">Start Thread ID: ${event.start_tid}</strong>`);
                        lines.push(`<strong style="color: #dc2626;">Stop Thread ID: ${event.stop_tid}</strong> (different thread!)`);
                    } else {
                        lines.push(`Thread ID: ${event.start_tid}`);
                    }
                }
                
                // Timestamps
                if (event.start !== null && event.start !== undefined) {
                    lines.push(`Start Time: ${event.start.toFixed(3)}Î¼s`);
                }
                if (event.stop !== null && event.stop !== undefined) {
                    lines.push(`Stop Time: ${event.stop.toFixed(3)}Î¼s`);
                }
                if (event.start !== null && event.start !== undefined && event.stop !== null && event.stop !== undefined) {
                    const calculatedDuration = event.stop - event.start;
                    lines.push(`Duration: ${calculatedDuration.toFixed(3)}Î¼s (${(calculatedDuration / 1000).toFixed(3)}ms)`);
                    // Also show stored duration if it exists and differs significantly
                    if (event.duration !== null && event.duration !== undefined && 
                        Math.abs(event.duration - calculatedDuration) > 0.001) {
                        lines.push(`  (Stored duration: ${event.duration.toFixed(3)}Î¼s)`);
                    }
                } else if (event.duration !== null && event.duration !== undefined) {
                    // Show stored duration if start/stop are missing
                    lines.push(`Duration: ${event.duration.toFixed(3)}Î¼s (${(event.duration / 1000).toFixed(3)}ms) [from stored field]`);
                }
                
                if (event.extCorrId !== null && event.extCorrId !== undefined) {
                    lines.push(`<strong style="color: #059669;">External Correlation ID: ${event.extCorrId}</strong>`);
                }
                
                if (event.corrId !== null && event.corrId !== undefined) {
                    lines.push(`CUPTI Correlation ID: ${event.corrId}`);
                }
                
                // CUPTI-specific details
                if (event.details && Object.keys(event.details).length > 0) {
                    lines.push('');
                    lines.push('Activity Details:');
                    for (const [key, value] of Object.entries(event.details)) {
                        if (typeof value === 'object') {
                            lines.push(`  ${key}: ${JSON.stringify(value)}`);
                        } else {
                            lines.push(`  ${key}: ${value}`);
                        }
                    }
                }
                
                // Show correlated NCCL events (using composite key with PID)
                if (event.extCorrId !== null && event.extCorrId !== undefined && eventsData.extCorrIdToNcclEvents) {
                    const pid = event.start_pid !== null && event.start_pid !== undefined 
                        ? event.start_pid 
                        : (event.stop_pid !== null && event.stop_pid !== undefined ? event.stop_pid : null);
                    const correlationKey = pid !== null ? `${event.extCorrId}_${pid}` : String(event.extCorrId);
                    const correlatedEvents = eventsData.extCorrIdToNcclEvents.get(correlationKey) || [];
                    if (correlatedEvents.length > 0) {
                        lines.push('');
                        lines.push(`<strong style="color: #059669;">Correlated NCCL Events (${correlatedEvents.length}):</strong>`);
                        correlatedEvents.forEach((ncclKey, idx) => {
                            const ncclEvent = eventsData.events[ncclKey];
                            if (ncclEvent) {
                                lines.push(`  ${idx + 1}. ${ncclEvent.type_name || ncclEvent.type || 'Unknown'}`);
                                if (ncclEvent.func) {
                                    lines.push(`     Function: ${ncclEvent.func}`);
                                }
                                if (ncclEvent.rank !== undefined && ncclEvent.rank !== null) {
                                    lines.push(`     Rank: ${ncclEvent.rank}`);
                                }
                            }
                        });
                    }
                }
            } else {
                // NCCL Event Information
            // Event descriptor type (most important)
            if (event.type_name) {
                lines.push(`Event Type: ${event.type_name}`);
            } else if (event.type) {
                lines.push(`Event Type: ${event.type}`);
            }
            
            // Function name
            if (event.func) {
                lines.push(`Function: ${event.func}`);
            }
            
            // Sequence number (for Coll events)
            if (event.seq_number !== undefined && event.seq_number !== null) {
                lines.push(`Sequence Number: ${event.seq_number}`);
            }
            
            // Basic info
            lines.push(`Rank: ${event.rank !== undefined ? event.rank : 'N/A'}`);
                
                // Show correlation ID if present
                if (event.extCorrId !== null && event.extCorrId !== undefined) {
                    lines.push(`<strong style="color: #059669;">External Correlation ID: ${event.extCorrId}</strong>`);
                }
                
                // Show correlated CUPTI activities (using composite key with PID)
                if (event.extCorrId !== null && event.extCorrId !== undefined && eventsData.extCorrIdToCuptiActivities) {
                    const pid = event.start_pid !== null && event.start_pid !== undefined 
                        ? event.start_pid 
                        : (event.stop_pid !== null && event.stop_pid !== undefined ? event.stop_pid : null);
                    const correlationKey = pid !== null ? `${event.extCorrId}_${pid}` : String(event.extCorrId);
                    const correlatedActivities = eventsData.extCorrIdToCuptiActivities.get(correlationKey) || [];
                    if (correlatedActivities.length > 0) {
                        lines.push('');
                        lines.push(`<strong style="color: #059669;">Correlated CUPTI Activities (${correlatedActivities.length}):</strong>`);
                        correlatedActivities.forEach((activityKey, idx) => {
                            const activity = eventsData.cuptiActivities[activityKey];
                            if (activity) {
                                lines.push(`  ${idx + 1}. ${activity.type_name || activity.type || 'Unknown'}`);
                                if (activity.name) {
                                    lines.push(`     Kernel: ${activity.name}`);
                                }
                                if (activity.deviceId !== null && activity.deviceId !== undefined) {
                                    lines.push(`     Device: ${activity.deviceId}`);
                                }
                            }
                        });
                    }
                }
            }
            
            // Common fields (for NCCL events only, not CUPTI activities)
            if (!event.isCuptiActivity) {
            if (event.commid) {
                // Show commid with shortened display
                const shortId = event.commid.length > 12 ? '...' + event.commid.slice(-12) : event.commid;
                const commIdx = eventsData.commids ? eventsData.commids.indexOf(event.commid) + 1 : '?';
                lines.push(`<strong style="color: #ca8a04;">Communicator #${commIdx}</strong> (${shortId})`);
            }
            if (event.ctx) {
                lines.push(`Context: ${event.ctx}`);
            }
            
            // GPU UUID
            if (event.gpuUuid) {
                lines.push(`GPU UUID: ${event.gpuUuid}`);
            }
            
            // PXN (Proxy Network) information
            if (event.isPxn) {
                lines.push(`<strong style="color: #dc2626;">PXN Event</strong>`);
                if (event.myPid !== undefined && event.myPid !== null) {
                    lines.push(`  My PID: ${event.myPid}`);
                }
                if (event.originPid !== undefined && event.originPid !== null) {
                    lines.push(`  Origin PID: ${event.originPid}`);
                }
            }
            
            // Thread IDs
            if (event.start_tid !== undefined && event.start_tid !== null) {
                if (event.stop_tid !== undefined && event.stop_tid !== null && event.start_tid !== event.stop_tid) {
                    // Different threads for start and stop - highlight this!
                    lines.push(`<strong style="color: #dc2626;">Start Thread ID: ${event.start_tid}</strong>`);
                    lines.push(`<strong style="color: #dc2626;">Stop Thread ID: ${event.stop_tid}</strong> (different thread!)`);
                } else {
                    lines.push(`Thread ID: ${event.start_tid}`);
                }
            } else if (event.stop_tid !== undefined && event.stop_tid !== null) {
                lines.push(`Thread ID (stop): ${event.stop_tid}`);
            }
            
            // Process IDs
            if (event.start_pid !== undefined && event.start_pid !== null) {
                if (event.stop_pid !== undefined && event.stop_pid !== null && event.start_pid !== event.stop_pid) {
                    // Different processes for start and stop - highlight this!
                    lines.push(`<strong style="color: #dc2626;">Start Process ID: ${event.start_pid}</strong>`);
                    lines.push(`<strong style="color: #dc2626;">Stop Process ID: ${event.stop_pid}</strong> (different process!)`);
                } else {
                    lines.push(`Process ID: ${event.start_pid}`);
                }
            } else if (event.stop_pid !== undefined && event.stop_pid !== null) {
                lines.push(`Process ID (stop): ${event.stop_pid}`);
            }
            
            if (event.eventAddr) {
                lines.push(`Event Address: ${event.eventAddr}`);
            }
            
            // Parent object address (if different from parent event's address)
            if (event.parentObj && event.parentObj !== 'null' && event.parentObj !== null) {
                lines.push(`Parent Object Address: ${event.parentObj}`);
            }
            
            // Timestamps
            if (event.start !== null) {
                lines.push(`Start Time: ${event.start.toFixed(3)}Î¼s`);
            }
            if (event.stop !== null) {
                lines.push(`Stop Time: ${event.stop.toFixed(3)}Î¼s`);
            }
            if (event.start !== null && event.stop !== null) {
                const calculatedDuration = event.stop - event.start;
                lines.push(`Duration: ${calculatedDuration.toFixed(3)}Î¼s (${(calculatedDuration / 1000).toFixed(3)}ms)`);
                // Also show stored duration if it exists and differs significantly
                if (event.duration !== null && event.duration !== undefined && 
                    Math.abs(event.duration - calculatedDuration) > 0.001) {
                    lines.push(`  (Stored duration: ${event.duration.toFixed(3)}Î¼s)`);
                }
            } else if (event.duration !== null && event.duration !== undefined) {
                // Show stored duration if start/stop are missing
                lines.push(`Duration: ${event.duration.toFixed(3)}Î¼s (${(event.duration / 1000).toFixed(3)}ms) [from stored field]`);
            }
            
            // All event details (from log file)
            if (event.details && Object.keys(event.details).length > 0) {
                lines.push('');
                lines.push('Event Details:');
                for (const [key, value] of Object.entries(event.details)) {
                    if (typeof value === 'object') {
                        lines.push(`  ${key}: ${JSON.stringify(value)}`);
                    } else {
                        lines.push(`  ${key}: ${value}`);
                    }
                }
            }
            
            // Parent-child relationship information
            if (eventsData.event_to_parent && eventsData.event_to_parent[event._key]) {
                const parentId = eventsData.event_to_parent[event._key];
                const parentEvent = eventsData.events[parentId];
                if (parentEvent) {
                    lines.push('');
                    lines.push('<strong style="color: #0d9488;">Parent Event:</strong>');
                    lines.push(`  Type: ${parentEvent.type_name || parentEvent.type || 'Unknown'}`);
                    if (parentEvent.func) {
                        lines.push(`  Function: ${parentEvent.func}`);
                    }
                    lines.push(`  Rank: ${parentEvent.rank}`);
                    if (parentEvent.eventAddr) {
                        lines.push(`  Address: ${parentEvent.eventAddr}`);
                    }
                }
            }
            
            if (eventsData.parent_child_map && eventsData.parent_child_map[event._key]) {
                const children = eventsData.parent_child_map[event._key];
                lines.push('');
                lines.push(`<strong style="color: #0d9488;">Child Events (${children.length}):</strong>`);
                children.forEach((childId, idx) => {
                    const childEvent = eventsData.events[childId];
                    if (childEvent) {
                        const childAddr = childEvent.eventAddr ? ` (${childEvent.eventAddr})` : '';
                        lines.push(`  ${idx + 1}. ${childEvent.type_name || childEvent.type || 'Unknown'}${childAddr}`);
                        if (childEvent.func) {
                            lines.push(`     Function: ${childEvent.func}`);
                        }
                    }
                });
            }
            
            // State information (all states, with highlight if one is hovered)
            if (event.states && event.states.length > 0) {
                lines.push('');
                lines.push(`State Transitions (${event.states.length}):`);
                event.states.forEach((state, idx) => {
                    const isHovered = hoveredState && state.timestamp === hoveredState.timestamp && 
                                     state.state_name === hoveredState.state_name;
                    const prefix = isHovered ? '<strong style="color: #b91c1c;">â' : '  [';
                    const suffix = isHovered ? '</strong>' : ']';
                    const tidInfo = state.tid !== undefined && state.tid !== null ? ` tid=${state.tid}` : '';
                    const pidInfo = state.pid !== undefined && state.pid !== null ? ` pid=${state.pid}` : '';
                    lines.push(`${prefix}${idx + 1}${suffix} ${state.state_name || 'Unknown'} (ID: ${state.state_id || 'N/A'}${tidInfo}${pidInfo}) at ${state.timestamp.toFixed(3)}Î¼s`);
                    if (state.details && Object.keys(state.details).length > 0) {
                        for (const [key, value] of Object.entries(state.details)) {
                            lines.push(`      ${key}: ${value}`);
                        }
                    }
                });
            }
            } // End of if (!event.isCuptiActivity)
            
            // Display in info panel (with line breaks for readability)
            const infoText = document.getElementById('info-text');
            infoText.innerHTML = lines.join('<br>');
            infoText.style.textAlign = 'left';
            infoText.style.padding = '10px';
        }
        
        // Initialize
        loadEvents();
    </script>
</body>
</html>

